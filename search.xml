<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《终身成长》读后感</title>
    <url>/posts/40c42b37.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 02 2020 23:48:26 GMT+0800 (GMT+08:00) --><p>&ensp;&ensp;&ensp;&ensp;记得曾经读过一句话：在这个世界上，有八十岁的“常青树”，也有二十岁的“朽木”。活到老，学到老，只有不断学习才能顺应现代快速发展的时代。而《终身成长》这本书让我们从思维模式的角度，找到了自己恐惧、苦恼和失败的原因。同时，它也帮助我们突破这些阻碍，获得更多成长。</p><a id="more"></a><p>&ensp;&ensp;&ensp;&ensp;本书把人的思维模式分成两种：一种是固定型思维，他们对自身能力评估非好即坏；相信自身才能是不变的，不屑于努力，并且热衷、在乎别人的评判和结果导向，总是掩饰自己不足，往往更易焦虑和抑郁，遇挫时容易放弃，拒绝自省，一旦失败，一蹶不振。而成长型思维模式的人相信能力可以培养，认为能力是可以通过努力来培养的，信任团队和人才的力量，会把挫折、失败当作一种体验和学习经历，善于总结经验，不会因为失败而气馁。</p><p>&ensp;&ensp;&ensp;&ensp;固定型思维决定你能用多长时间进入一个专业领域；成长型思维决定你能在专业领域走多远。固定型思维模式会限制人的成就，相反，成长型思维模式能够帮助人们的发展能力，取得成就。书中作者通过对某医科大学学生的行为跟踪观察，发现拥有成长型思维模式的学生，在学习中注重学习方法，他们善于寻找学习规律，并能从错误中吸取教训。</p><p>&ensp;&ensp;&ensp;&ensp;那么如何实现终身成长呢？其实，我们每个人都是固定型思维和成长型思维的矛盾体。我们首先要能勇于发现并承认自己的固定型思维，分析自身原因，勇敢面对和接受，用成长型思维去帮助自己拥有正确的成长心态，训练积极强大的内心，通过自己的努力，克服脆弱、克服恐惧，消除自我，化阻碍为支持，从失败和挫折里受益，让自己变得更强大。成长是每个人一辈子的事，它无关年纪。无论何时，停滞成长，才是最可怕的衰老。改变也许艰难，却从未有人说过不值。从现在起，就培养我们的成长型思维吧，让我们终身成长。</p><blockquote><p>注：吾不以不及第为耻,吾以不及第动吾心为耻<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;——王阳明</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>爱读书</category>
      </categories>
      <tags>
        <tag>爱读书</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue父子组件生命周期</title>
    <url>/posts/77185e63.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 02 2020 23:48:26 GMT+0800 (GMT+08:00) --><p>Vue的生命周期一直是vue中的基础以及重要的基石，这里详细解析Vue父子组件的生命周期，单组件生命周期不在详细描述，如需了解请参考我的上一篇文章<a href="/posts/6f7db675.html">Vue组件生命周期</a></p><a id="more"></a><h1 id="Vue父子组件生命周期执行顺序"><a href="#Vue父子组件生命周期执行顺序" class="headerlink" title="Vue父子组件生命周期执行顺序"></a>Vue父子组件生命周期执行顺序</h1><p>下面我们在实际的代码执行过程中理解父子组件生命周期创建过程以及钩子函数执行的实时状态变化。</p><p>测试基于下面的代码，引入vue.js文件后即可执行。（打开页面后，再按一次刷新会自动进入debugger状态）</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HTML"><figure class="iseeu highlight /html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">my-components</span> <span class="attr">:msg</span>=<span class="string">"msg1"</span> <span class="attr">v-if</span>=<span class="string">"show"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-components</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> child = &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">	template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>from child: </span><span class="template-variable">&#123;&#123;childMsg&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>',</span></span></span><br><span class="line"><span class="actionscript">	props: [<span class="string">'msg'</span>],</span></span><br><span class="line"><span class="actionscript">	data: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">		<span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">			childMsg: <span class="string">'child'</span></span></span><br><span class="line">		&#125;   </span><br><span class="line">	&#125;,</span><br><span class="line"><span class="actionscript">	beforeCreate: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">		<span class="keyword">debugger</span>;</span></span><br><span class="line">	&#125;,</span><br><span class="line"><span class="actionscript">	created: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">		<span class="keyword">debugger</span>;</span></span><br><span class="line">	&#125;,</span><br><span class="line"><span class="actionscript">	beforeMount: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">		<span class="keyword">debugger</span>;</span></span><br><span class="line">	&#125;,</span><br><span class="line"><span class="actionscript">	mounted: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">		<span class="keyword">debugger</span>;</span></span><br><span class="line">	&#125;,</span><br><span class="line"><span class="actionscript">	deactivated: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">		alert(<span class="string">"keepAlive停用"</span>);</span></span><br><span class="line">	&#125;,</span><br><span class="line"><span class="actionscript">	activated: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">		<span class="built_in">console</span>.log(<span class="string">'component activated'</span>);</span></span><br><span class="line">	&#125;,</span><br><span class="line"><span class="actionscript">	beforeDestroy: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">		<span class="built_in">console</span>.group(<span class="string">'beforeDestroy 销毁前状态===============》'</span>);</span></span><br><span class="line"><span class="actionscript">		<span class="keyword">var</span> state = &#123;</span></span><br><span class="line"><span class="actionscript">			<span class="string">'el'</span>: <span class="keyword">this</span>.$el,</span></span><br><span class="line"><span class="actionscript">			<span class="string">'data'</span>: <span class="keyword">this</span>.$data,</span></span><br><span class="line"><span class="actionscript">			<span class="string">'message'</span>: <span class="keyword">this</span>.message</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="javascript">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">		<span class="built_in">console</span>.log(state);</span></span><br><span class="line">	&#125;,</span><br><span class="line"><span class="actionscript">	destroyed: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">		<span class="built_in">console</span>.group(<span class="string">'destroyed 销毁完成状态===============》'</span>);</span></span><br><span class="line"><span class="actionscript">		<span class="keyword">var</span> state = &#123;</span></span><br><span class="line"><span class="actionscript">			<span class="string">'el'</span>: <span class="keyword">this</span>.$el,</span></span><br><span class="line"><span class="actionscript">			<span class="string">'data'</span>: <span class="keyword">this</span>.$data,</span></span><br><span class="line"><span class="actionscript">			<span class="string">'message'</span>: <span class="keyword">this</span>.message</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="javascript">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">		<span class="built_in">console</span>.log(state);</span></span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">	el: <span class="string">'#app'</span>,</span></span><br><span class="line">	data: &#123;</span><br><span class="line"><span class="actionscript">			message: <span class="string">'father'</span>,</span></span><br><span class="line"><span class="actionscript">			msg1: <span class="string">"hello"</span>,</span></span><br><span class="line"><span class="actionscript">			show: <span class="literal">true</span></span></span><br><span class="line">		&#125;,</span><br><span class="line"><span class="actionscript">	beforeCreate: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">		<span class="keyword">debugger</span>;</span></span><br><span class="line">	&#125;,</span><br><span class="line"><span class="actionscript">	created: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">		<span class="keyword">debugger</span>;</span></span><br><span class="line">	&#125;,</span><br><span class="line"><span class="actionscript">	beforeMount: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">		<span class="keyword">debugger</span>;</span></span><br><span class="line">	&#125;,</span><br><span class="line"><span class="actionscript">	mounted: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">		<span class="keyword">debugger</span>;    </span></span><br><span class="line">	&#125;,</span><br><span class="line"><span class="actionscript">	beforeUpdate: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">		alert(<span class="string">"页面视图更新前"</span>);</span></span><br><span class="line">		</span><br><span class="line">	&#125;,</span><br><span class="line"><span class="actionscript">	updated: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">		alert(<span class="string">"页面视图更新后"</span>);</span></span><br><span class="line">	&#125;,</span><br><span class="line"><span class="actionscript">	beforeDestroy: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">		<span class="built_in">console</span>.group(<span class="string">'beforeDestroy 销毁前状态===============》'</span>);</span></span><br><span class="line"><span class="actionscript">		<span class="keyword">var</span> state = &#123;</span></span><br><span class="line"><span class="actionscript">			<span class="string">'el'</span>: <span class="keyword">this</span>.$el,</span></span><br><span class="line"><span class="actionscript">			<span class="string">'data'</span>: <span class="keyword">this</span>.$data,</span></span><br><span class="line"><span class="actionscript">			<span class="string">'message'</span>: <span class="keyword">this</span>.message</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="javascript">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">		<span class="built_in">console</span>.log(state);</span></span><br><span class="line">	&#125;,</span><br><span class="line"><span class="actionscript">	destroyed: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">		<span class="built_in">console</span>.group(<span class="string">'destroyed 销毁完成状态===============》'</span>);</span></span><br><span class="line"><span class="actionscript">		<span class="keyword">var</span> state = &#123;</span></span><br><span class="line"><span class="actionscript">			<span class="string">'el'</span>: <span class="keyword">this</span>.$el,</span></span><br><span class="line"><span class="actionscript">			<span class="string">'data'</span>: <span class="keyword">this</span>.$data,</span></span><br><span class="line"><span class="actionscript">			<span class="string">'message'</span>: <span class="keyword">this</span>.message</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="javascript">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">		<span class="built_in">console</span>.log(state);</span></span><br><span class="line">	&#125;,</span><br><span class="line">	components: &#123;</span><br><span class="line"><span class="actionscript">		<span class="string">'my-components'</span>: child</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h2 id="生命周期调试"><a href="#生命周期调试" class="headerlink" title="生命周期调试"></a>生命周期调试</h2><p>首先我们创建了一个Vue实例vm，将其挂载到页面中id为”app”的元素上。</p><h3 id="一、根组件的beforeCreate阶段"><a href="#一、根组件的beforeCreate阶段" class="headerlink" title="一、根组件的beforeCreate阶段"></a>一、根组件的beforeCreate阶段</h3><p><img src="/posts/77185e63/beforeCreate.png" alt><br>可以看出，在调用<code>beforeCreate()</code>函数时，只进行了一些必要的初始化操作（例如一些全局的配置和根实例的一些属性初始化），此时<code>data</code>属性为<code>undefined</code>，没有可供操作的数据。</p><h3 id="二、根组件的Created阶段"><a href="#二、根组件的Created阶段" class="headerlink" title="二、根组件的Created阶段"></a>二、根组件的Created阶段</h3><p><img src="/posts/77185e63/Created.png" alt><br>调用<code>created()</code>函数，在这一步，实例已完成以下的配置：数据代理和动态数据绑定(<code>data observer</code>)，属性和方法的运算， <code>watch/event</code> 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</p><h3 id="三、根组件的beforeMount阶段"><a href="#三、根组件的beforeMount阶段" class="headerlink" title="三、根组件的beforeMount阶段"></a>三、根组件的beforeMount阶段</h3><p><img src="/posts/77185e63/Vmount.png" alt><br><img src="/posts/77185e63/beforeMount.png" alt></p><p>在调用<code>boforeMount()</code>函数前首先会判断对象是否有el选项。如果有的话就继续向下编译，如果没有el选项，则停止编译，也就意味着停止了生命周期，直到在该vue实例上调用<code>vm.$mount(el)</code></p><p>在这个例子中，我们有el元素，因此会调用<code>boforeMount()</code>函数,此时已经开始执行模板解析函数，但还没有将$el元素挂载页面，页面视图因此也未更新。在标红处，还是 ，这里就是应用的 <code>Virtual DOM（虚拟Dom）</code>技术，先把坑占住了。到后面<code>mounted</code>挂载的时候再把值渲染进去。</p><h3 id="四、子组件的beforeCreate、Created、beforeMount、Mounted阶段"><a href="#四、子组件的beforeCreate、Created、beforeMount、Mounted阶段" class="headerlink" title="四、子组件的beforeCreate、Created、beforeMount、Mounted阶段"></a>四、子组件的beforeCreate、Created、beforeMount、Mounted阶段</h3><p>在父组件执行<code>beforeMount</code>阶段后，进入子组件的<code>beforeCreate、Created、beforeMount</code>阶段，这些阶段和父组件类似。<code>beforeMount</code>阶段后，执行的是<code>Mounted</code>阶段，该阶段时子组件已经挂载到父组件上，并且父组件随之挂载到页面中。</p><p>由下图可以知道，在beforeMount阶段之后、Mounted阶段之前，数据已经被加载到视图上了，即$el元素被挂载到页面时触发了视图的更新。</p><p><img src="/posts/77185e63/child.png" alt></p><h3 id="五、子组件的activated阶段"><a href="#五、子组件的activated阶段" class="headerlink" title="五、子组件的activated阶段"></a>五、子组件的activated阶段</h3><p>我们发现在子父组件全部挂载到页面之后被触发。这是因为子组件<code>my-components</code>被<code>&lt;keep-alive&gt;</code> 包裹，随$el的挂载被触发。如果子组件没有被<code>&lt;keep-alive&gt;</code>包裹，那么该阶段将不会被触发。</p><h3 id="六、父组件的mounted阶段"><a href="#六、父组件的mounted阶段" class="headerlink" title="六、父组件的mounted阶段"></a>六、父组件的mounted阶段</h3><p>mounted执行时：此时el已经渲染完成并挂载到实例上。<br>至此，从Vue实例的初始化到将新的模板挂载到页面上的阶段已经完成，退出debugger。下面我们来看一下<code>deactivated、beforeUpdate、updated、beforeDestroy、destroyed</code>钩子函数。</p><h3 id="七、deactivated、beforeUpdate、updated阶段"><a href="#七、deactivated、beforeUpdate、updated阶段" class="headerlink" title="七、deactivated、beforeUpdate、updated阶段"></a>七、deactivated、beforeUpdate、updated阶段</h3><p>由生命周期函数可知：当数据变化后、虚拟DOM渲染重新渲染页面前会触发<code>beforeUpdate()</code>函数，此时视图还未改变。当虚拟DOM渲染页面视图更新后会触发<code>updated()</code>函数。</p><p><img src="/posts/77185e63/Update.png" alt><br>我们不妨改变<code>vm.show = false</code>，当修改这个属性时，不仅会触发<code>beforeUpdate</code>、<code>updated</code>函数，还会触发<code>deactivated</code>函数（因为keep-alive 组件停用时调用）。我们不妨想一下<code>deactivated</code>函数会在<code>beforeUpdate</code>后还是<code>updated</code>后调用。</p><p>我们在控制台输入<code>vm.show = false</code>。得到三者的调用顺序分别为<code>beforeUpdate</code>、<code>deactivated</code>、<code>updated</code>。我们可以知道的是<code>deactivated</code>函数的触发时间是在视图更新时触发。因为当视图更新时才能知道keep-alive组件被停用了。</p><p><img src="/posts/77185e63/childbeforeUpdate.png" alt></p><p><img src="/posts/77185e63/deactivated.png" alt></p><p><img src="/posts/77185e63/updated.png" alt></p><h3 id="八、beforeDestroy和destroyed钩子函数间的生命周期"><a href="#八、beforeDestroy和destroyed钩子函数间的生命周期" class="headerlink" title="八、beforeDestroy和destroyed钩子函数间的生命周期"></a>八、beforeDestroy和destroyed钩子函数间的生命周期</h3><p>现在我们对Vue实例进行销毁，调用app.$destroy()方法即可将其销毁，控制台测试如下：</p><p><img src="/posts/77185e63/destroyed.png" alt></p><p>我们发现实例依然存在，但是此时变化已经发生在了其他地方。</p><p><code>beforeDestroy</code>钩子函数在实例销毁之前调用。在这一步，实例仍然完全可用。</p><p><code>destroyed</code>钩子函数在Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁（也就是说子组件也会触发相应的函数）。这里的销毁并不指代’抹去’，而是表示’解绑’。</p><p>销毁时<code>beforeDestory</code>函数的传递顺序为由父到子，destory的传递顺序为由子到父。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>加载渲染过程<blockquote><p>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</p></blockquote></li><li>子组件更新过程<blockquote><p>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</p></blockquote></li><li>父组件更新过程<blockquote><p>父beforeUpdate-&gt;父updated</p></blockquote></li><li>销毁过程<blockquote><p>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</p></blockquote></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中的$nextTick机制</title>
    <url>/posts/d03e3346.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 02 2020 23:48:26 GMT+0800 (GMT+08:00) --><h2 id="nextTick-出现的前提"><a href="#nextTick-出现的前提" class="headerlink" title="nextTick 出现的前提"></a>nextTick 出现的前提</h2><p>因为Vue是异步驱动视图更新数据的，即当我们在事件中修改数据时，视图并不会即时的更新，而是等在同一事件循环的所有数据变化完成后，再进行视图更新。类似于Event Loop事件循环机制。</p><a id="more"></a><h3 id="官方介绍"><a href="#官方介绍" class="headerlink" title="官方介绍"></a>官方介绍</h3><p>首先我们看下官网给出的介绍:</p><h3 id="Vue-nextTick-callback-context"><a href="#Vue-nextTick-callback-context" class="headerlink" title="Vue.nextTick([callback, context])"></a>Vue.nextTick([callback, context])</h3><ul><li><p>参数:</p><blockquote><p><code>{Function} [callback]</code><br><code>{Object} [context]</code></p></blockquote></li><li><p>用法:<br>在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后DOM。</p></li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改数据</span></span><br><span class="line">vm.msg = <span class="string">'Hello'</span></span><br><span class="line"><span class="comment">// 当我们在这里调用DOM的数据时，它其实还没有更新</span></span><br><span class="line">Vue.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// DOM 更新了</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.1.0新增 Promise用法</span></span><br><span class="line">Vue.nextTick()</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此时DOM已经更新</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><blockquote><p>2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不原生支持 Promise (IE：你们都看我干嘛)，你得自己提供 polyfill。</p></blockquote><h2 id="DOM更新循环"><a href="#DOM更新循环" class="headerlink" title="DOM更新循环"></a>DOM更新循环</h2><p>首先，Vue实现响应式并不是在数据改变后就立即更新DOM，而是在一次事件循环的所有数据变化后再异步执行DOM更新.</p><p>有关异步以及事件循环，可以看下我之前写过的一篇关于文章<a href="/posts/5cd28b9d.html">JS中的异步</a></p><p>如果不想去详细了解，这边我就简单总结一下事件循环:</p><p>同步代码的执行 =&gt; 查找异步队列，进入执行栈，执行Callback1[事件循环1] =&gt; 查找异步队列，进入执行栈，执行Callback2[事件循环2] =&gt; …..</p><blockquote><p>即每个异步的Callback都会再独立形成一次事件循环<br>所以我们可以退出nextTick的触发时机<br>一次事件循环中的代码执行完毕 =&gt; DOM更新 =&gt; 触发nextTick的回调 =&gt; 进入下一循环</p></blockquote><p>可能只凭一些概念性的讲解还是无法对nextTick机制有很清晰的了解，还是上个示例来了解一下吧。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"app"</span>&gt;</span><br><span class="line">        &lt;div ref=<span class="string">"contentDiv"</span>&gt;&#123;&#123;content&#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;在nextTick执行前获取内容:&#123;&#123;content1&#125;&#125;&lt;/</span>div&gt;</span><br><span class="line">        &lt;div&gt;在nextTick执行之后获取内容:&#123;&#123;content2&#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;在nextTick执行前获取内容:&#123;&#123;content3&#125;&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">	name:<span class="string">'App'</span>,</span><br><span class="line">	data: &#123;</span><br><span class="line">		content: <span class="string">'Before NextTick'</span>,</span><br><span class="line">		content1: <span class="string">''</span>,</span><br><span class="line">		content2: <span class="string">''</span>,</span><br><span class="line">		content3: <span class="string">''</span></span><br><span class="line">	&#125;,</span><br><span class="line">	methods: &#123;</span><br><span class="line">		changeContent () &#123;</span><br><span class="line">			<span class="keyword">this</span>.content = <span class="string">'After NextTick'</span> <span class="comment">// 在此处更新content的数据</span></span><br><span class="line">			<span class="keyword">this</span>.content1 = <span class="keyword">this</span>.$refs.contentDiv.innerHTML <span class="comment">//获取DOM中的数据</span></span><br><span class="line">			<span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">				<span class="comment">// 在nextTick的回调中获取DOM中的数据</span></span><br><span class="line">				<span class="keyword">this</span>.content2 = <span class="keyword">this</span>.$refs.contentDiv.innerHTML </span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="keyword">this</span>.content3 = <span class="keyword">this</span>.$refs.contentDiv.innerHTML</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	mount () &#123;</span><br><span class="line">		<span class="keyword">this</span>.changeContent()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></div><p>当我们打开页面后我们可以发现结果为:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">After NextTick</span><br><span class="line"></span><br><span class="line">在nextTick执行前获取内容:Before NextTick</span><br><span class="line"></span><br><span class="line">在nextTick执行之后获取内容:After NextTick</span><br><span class="line"></span><br><span class="line">在nextTick执行前获取内容:Before NextTick</span><br></pre></td></tr></table></figure></div><p>所以我们可以知道,虽然<code>content1</code>和<code>content3</code>获得内容的语句是写在<code>content</code>数据改变语句之后的，但他们属于同一个事件循环中，所以<code>content1</code>和<code>content3</code>获取的还是 ‘Before NextTick’ ,而<code>content2</code>获得内容的语句写在<code>nextTick</code>的回调中，在DOM更新之后再执行，所以获取的是更新后的 ‘After NextTick’。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>下面是一些nextTick的主要应用场景</p><h3 id="在created-生命周期执行DOM操作"><a href="#在created-生命周期执行DOM操作" class="headerlink" title="在created 生命周期执行DOM操作"></a>在created 生命周期执行DOM操作</h3><p>当在<code>created()</code>生命周期中直接执行DOM操作是不可取的，因为此时的DOM并未进行任何的渲染。所以解决办法是将DOM操作写进<code>Vue.nextTick()</code>的回调函数中。或者是将操作放入<code>mounted()</code>钩子函数中</p><h3 id="在数据变化后需要进行基于DOM结构的操作"><a href="#在数据变化后需要进行基于DOM结构的操作" class="headerlink" title="在数据变化后需要进行基于DOM结构的操作"></a>在数据变化后需要进行基于DOM结构的操作</h3><p>在我们更新数据后，如果还有操作要根据更新数据后的DOM结构进行，那么我们应当将这部分操作放入<strong>Vue.nextTick()</strong>回调函数中</p><p>这部分的详细原因在Vue的官方文档中解释的非常清晰:</p><blockquote><p>可能你还没有注意到，Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 <code>Promise.then</code> 和 <code>MessageChannel</code>，如果执行环境不支持，会采用 <code>setTimeout(fn, 0)</code> 代替。<br>例如，当你设置 <code>vm.someData = &#39;new value&#39;</code> ，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 <code>Vue.nextTick(callback)</code> 。这样回调函数在 DOM 更新完成后就会调用。</p></blockquote><h2 id="附：nextTick源码解析"><a href="#附：nextTick源码解析" class="headerlink" title="附：nextTick源码解析"></a>附：nextTick源码解析</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> nextTick = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 存放所有的回调函数</span></span><br><span class="line">  <span class="keyword">const</span> callbacks = []</span><br><span class="line">  <span class="comment">// 是否正在执行回调函数的标志</span></span><br><span class="line">  <span class="keyword">let</span> pending = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 触发执行回调函数</span></span><br><span class="line">  <span class="keyword">let</span> timerFunc</span><br><span class="line"><span class="comment">// 处理回调函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">nextTickHandler</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    pending = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>)</span><br><span class="line">    callbacks.length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">      <span class="comment">// 执行回调函数</span></span><br><span class="line">      copies[i]()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// nextTick行为利用了微任务队列</span></span><br><span class="line">  <span class="comment">// 它可以通过原生Promise或者MutationObserver实现</span></span><br><span class="line">  <span class="comment">// MutationObserver已经有了广泛的浏览器支持，然而他仍然在UIWebView在ios系统9.3.3以上的</span></span><br><span class="line">  <span class="comment">// 系统有严重的Bug，问题发生在我们触摸事件的触发时。</span></span><br><span class="line">  <span class="comment">// 它会在我们触发一段时间后完全停止，所以原生Promise是有效可以利用的，我们会使用它:</span></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">    <span class="keyword">var</span> logError = <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="built_in">console</span>.error(err) &#125;</span><br><span class="line">    timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      p.then(nextTickHandler).catch(logError)</span><br><span class="line">      <span class="comment">// 在有问题的 UIWebViews 中，Promise.then 方法不会完全的停止，但它可能会在一个</span></span><br><span class="line">      <span class="comment">// 奇怪的状态卡住当我们把回调函数推入一个微任务队列但是这个队列并不是在冲洗中，知道</span></span><br><span class="line">      <span class="comment">// 浏览器需要做一些其他的任务时，例如：执行一个定时函数。因此我们可以"强制"微任务队</span></span><br><span class="line">      <span class="comment">// 列被冲洗通过加入一个空的定时函数</span></span><br><span class="line">      <span class="keyword">if</span> (isIOS) setTimeout(noop)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> MutationObserver !== <span class="string">'undefined'</span> &amp;&amp; (</span><br><span class="line">    isNative(MutationObserver) ||</span><br><span class="line">    <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">    MutationObserver.toString() === <span class="string">'[object MutationObserverConstructor]'</span></span><br><span class="line">  )) &#123;</span><br><span class="line">    <span class="comment">// 使用MutationObserver当Promise不可用时，</span></span><br><span class="line">    <span class="comment">// 例如 PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(nextTickHandler)</span><br><span class="line">    <span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line">    observer.observe(textNode, &#123;</span><br><span class="line">      characterData: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">      textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 当MutationObserver 和 Promise都不可以使用时</span></span><br><span class="line">    <span class="comment">// 我们使用setTimeOut来实现</span></span><br><span class="line">    <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">    timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setTimeout(nextTickHandler, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">queueNextTick</span> (<span class="params">cb?: Function, ctx?: Object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _resolve</span><br><span class="line">    callbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cb.call(ctx)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          handleError(e, ctx, <span class="string">'nextTick'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">        _resolve(ctx)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">      pending = <span class="literal">true</span></span><br><span class="line">      timerFunc()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        _resolve = resolve</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></div><p>我们通过源码可以知道，timeFunc这个函数起延迟执行的作用，它有三种实现方式</p><ul><li>Promise</li><li>MutationObserver</li><li>setTimeout</li></ul><p>其中<code>Promise</code>和 <code>setTimeout</code> 我们都不陌生，下面重点介绍一下<code>MutationObserver</code></p><p><code>MutationObserver</code>是HTML5中的新API，是个用来监视DOM变动的接口。他能监听一个DOM对象上发生的子节点删除、属性修改、文本内容修改等等。 调用过程很简单，但是有点不太寻常：你需要先给他绑回调：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mo = <span class="keyword">new</span> MutationObserver(callback)</span><br></pre></td></tr></table></figure></div><p>通过给<code>MutationObserver</code>的构造函数传入一个回调，能得到一个<code>MutationObserver</code>实例，这个回调就会在<code>MutationObserver</code>实例监听到变动时触发。</p><p>这个时候你只是给<code>MutationObserver</code>实例绑定好了回调，他具体监听哪个DOM、监听节点删除还是监听属性修改，还没有设置。而调用他的<code>observer</code>方法就可以完成这一步:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> domTarget = 你想要监听的dom节点</span><br><span class="line">mo.observe(domTarget, &#123;</span><br><span class="line">      characterData: <span class="literal">true</span> <span class="comment">//说明监听文本内容的修改。</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><p>在<code>nextTick</code>中 <code>MutationObserver</code>的作用就如下图所示。在监听到DOM更新后，调用回调函数。</p><p><img src="/posts/d03e3346/vue-nextTick.jpg" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在同一事件循环中，当所有的同步数据更新执行完毕后，才会调用nextTick</li><li>在同步执行环境中的数据完全更新完毕后，DOM才会开始渲染。</li><li>在同一个事件循环中，若存在多个nextTick，将会按最初的执行顺序进行调用。</li><li>每个异步的回调函数执行后都会存在一个独立的事件循环中，对应自己独立的nextTick</li><li>vue DOM的视图更新实现，，使用到了ES6的Promise及HTML5的MutationObserver，当环境不支持时，使用setTimeout(fn, 0)替代。上述的三种方法，均为异步API。其中MutationObserver类似事件，又有所区别；事件是同步触发，其为异步触发，即DOM发生变化之后，不会立刻触发，等当前所有的DOM操作都结束后触发。</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue渲染过程</title>
    <url>/posts/7f8f5d1.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 02 2020 23:48:26 GMT+0800 (GMT+08:00) --><p>Vue 推荐在绝大多数情况下使用 template 来创建你的 HTML。但是模板毕竟是模板，不是真实的dom节点。从模板到真实dom节点还需要经过一些步骤</p><a id="more"></a><ol><li>把模板编译为<code>render</code>函数</li><li>实例进行挂载, 根据根节点<code>render</code>函数的调用，递归的生成虚拟dom</li><li>对比虚拟dom，渲染到真实dom</li><li>组件内部data发生变化，组件和子组件引用data作为props重新调用<code>render</code>函数，生成虚拟dom, 返回到步骤3</li></ol><h2 id="第一步-模板到render"><a href="#第一步-模板到render" class="headerlink" title="第一步: 模板到render"></a>第一步: 模板到render</h2><p>在我们使用Vue的组件化进行开发应用的时候, 如果仔细的查看我们要引入的组件, 例子如下:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.vue </span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        hello word</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure></div><p>在我们的主入口main.js</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(App)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure></div><p><img src="/posts/7f8f5d1/render.png" alt></p><p>我们能够看到在我们引入的App这个模块，里面是一个对象，对象里面存在一个方法叫做<code>render</code>。在说<code>render</code>函数之前，我们可以想一想，每一次加载一个组件，然后对模板进行解析，解析完后，生成Dom，挂载到页面上。这样会导致效率很低效。而使用Vue-cli进行组件化开发，在我们引入组件的后，其实会有一个解析器(vue-loader)对此模板进行了解析，生成了<code>render</code>函数。当然，如果没有通过解析器解析为<code>render</code>函数，也没有关系，在组件第一次挂载的时候，Vue会自己进行解析</p><p>这样，能保证组件每次调用的都是<code>render</code>函数，使用<code>render</code>函数生成VNode。</p><h2 id="第二步：虚拟节点VNode"><a href="#第二步：虚拟节点VNode" class="headerlink" title="第二步：虚拟节点VNode"></a>第二步：虚拟节点VNode</h2><p>我们把Vue的实例挂载到<code>#app</code>, 会调用实例里面的<code>render</code>方法，生成虚拟DOM。来看看什么是虚拟节点，把例子修改一下。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> root = h(App)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'root:'</span>, root)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure></div><p><img src="/posts/7f8f5d1/vnode.png" alt><br>上面生成的VNode就是虚拟节点，虚拟节点里面有一个属性<code>elm</code>, 这个属性指向真实的DOM节点。因为VNode指向了真实的DOM节点，那么虚拟节点经过对比后，生成的DOM节点就可以直接进行替换。</p><p><strong>这样有什么好处呢？</strong></p><p>一个组件对象，如果内部的<code>data</code>发生变化，触发了<code>render</code>函数，重新生成了VNode节点。那么就可以直接找到所对应的节点，然后直接替换。那么这个过程只会在本组件内发生，不会影响其他的组件。于是组件与组件是隔离的。</p><p>例子如下:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">const</span> root = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    state: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">this</span>.state = <span class="literal">false</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; state &#125; = <span class="keyword">this</span> <span class="comment">// state 变化重新触发render</span></span><br><span class="line">    <span class="keyword">let</span> root = h(App)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'root:'</span>, root)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.vue</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  render: <span class="function">(<span class="params">h</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> app = h(<span class="string">'h1'</span>, [<span class="string">'hello world'</span>])</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'app:'</span>, app)</span><br><span class="line">    <span class="keyword">return</span> app</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></div><p><img src="/posts/7f8f5d1/Vnode2.png" alt><br>我们可以看到，当<code>main.js</code>中重新触发<code>render</code>函数的时候，<code>render</code>方法里面有引用App.vue这个子组件。但是并没有触发App.vue组件的的<code>render</code>函数。</p><p><span style="color:#e83e8c">在一个组件内，什么情况会触发render?</span></p><h2 id="如何才能触发组件的render"><a href="#如何才能触发组件的render" class="headerlink" title="如何才能触发组件的render"></a>如何才能触发组件的render</h2><p>数据劫持是Vue的一大特色，原理官方已经讲的很多了<a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">深入响应式原理</a>。在我们给组件的data的属性进行的赋值的时候(set)，此属性如果在组件内部初次渲染过程被引用(<code>data的属性被访问，也就是数据劫持的get</code>), 包括生命周期方法或者render方法。于是会触发组件的update(beforeUpdate -&gt; render -&gt; updated)。</p><blockquote><p>注: 为了防止data被多次set从而触发多次update, Vue把update存放到异步队列中。这样就能保证多次data的set只会触发一次update。</p></blockquote><p><span style="color:#e83e8c">当props会触发组件的重新渲染是怎么发生的呢？</span></p><p>把父组件的<code>data</code>通过<code>props</code>传递给子组件的时候，子组件在初次渲染的时候生命周期或者<code>render</code>方法，有调用<code>data</code>相关的<code>props</code>的属性, 这样子组件也被添加到父组件的<code>data</code>的相关属性依赖中，这样父组件的<code>data</code>在<code>set</code>的时候，就相当于触发自身和子组件的<code>update</code>。</p><p><strong>例子如下:</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.vue</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    state: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.state = <span class="literal">true</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; state &#125; = <span class="keyword">this</span> <span class="comment">// state 变化重新触发render</span></span><br><span class="line">    <span class="keyword">let</span> root = h(App, &#123; <span class="attr">props</span>: &#123; <span class="attr">status</span>: state &#125; &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'root:'</span>, root)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.root = root</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.vue</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    status: <span class="built_in">Boolean</span></span><br><span class="line">  &#125;,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">h</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; status &#125; = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> app = h(<span class="string">'h1'</span>, [<span class="string">'hello world'</span>])</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'app:'</span>, app)</span><br><span class="line">    <span class="keyword">return</span> app</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></div><p><img src="/posts/7f8f5d1/render2.png" alt></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue组件通信</title>
    <url>/posts/383dff78.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 02 2020 23:48:26 GMT+0800 (GMT+08:00) --><p>vue 组件间的通信是 vue 开发中很基础也十分重要的部分，作为使用 vue 的开发者每天都在使用。同时，vue 通信也是面试中非常高频的问题，有很多面试题，都是围绕通信展开。</p><a id="more"></a><p>本文会介绍常见的通信方式，并分析每种方式的使用场景和注意点。</p><p>vue 中提倡单向数据流，这是为了保证数据流向的简洁性，使程序更易于理解。但对于一些边界情况，vue 也提供了隐性的通信方式，这些通信方式会打破单向数据流的原则，应该谨慎使用。</p><p>下面我们将组件通信分为父子组件通信 和 非父子组件通信进行分析。</p><h2 id="一、父子组件通信"><a href="#一、父子组件通信" class="headerlink" title="一、父子组件通信"></a>一、父子组件通信</h2><h3 id="props-和-emit"><a href="#props-和-emit" class="headerlink" title="props 和$emit"></a>props 和$emit</h3><p>props 最常见的父子通信接口，但是 props 是单向数据流的形式：父级 prop 的更新会向下流动到子组件中，但是反过来则不行</p><p>此时需要借助 vue 提供的事件监听机制来完成子组件向父组件数据流动更新的功能。 在子组件使用$emit 定义监听事件名称，在父组件使用 v-on 监听该事件，在事件中改变父组件的状态。</p><ul><li>父组件</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// father.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;Children :name=<span class="string">"name"</span> @close=<span class="string">"closeChildren"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">Children</span> /&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> Children <span class="keyword">from</span> <span class="string">'./children.vue'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name: <span class="string">'vue组件通信总结'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        Children</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        closeChildren() &#123;</span><br><span class="line">            <span class="comment">// todo</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></div><ul><li>子组件</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// children.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;&#123;&#123;name&#125;&#125;&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">        &lt;el-button</span></span><br><span class="line"><span class="regexp">            v-if="closeBtn"</span></span><br><span class="line"><span class="regexp">            circle</span></span><br><span class="line"><span class="regexp">            size="mini"</span></span><br><span class="line"><span class="regexp">            class="close_btn"</span></span><br><span class="line"><span class="regexp">            icon="el-icon-close"</span></span><br><span class="line"><span class="regexp">            @click="close"</span></span><br><span class="line"><span class="regexp">        &gt;&lt;/</span>el-button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    props: [<span class="string">"name"</span>],</span><br><span class="line">    methods: &#123;</span><br><span class="line">        close() &#123;</span><br><span class="line">          <span class="keyword">this</span>.$emit(<span class="string">"close"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></div><h3 id="v-model-指令"><a href="#v-model-指令" class="headerlink" title="v-model 指令"></a>v-model 指令</h3><p><code>v-model</code> 是用来在表单控件或者组件上创建双向绑定的，他的本质是 <code>v-bind</code> 和 <code>v-on</code> 的语法糖，在一个组件上使用 <code>v-model</code>，默认会为组件绑定名为 <code>value</code> 的 <code>prop</code> 和名为 <code>input</code> 的事件。</p><p>当我们组件中的某一个 <code>prop</code> 需要实现上面所说的<span style="color:#F60">双向绑定<span>时，<code>v-model</code> 就能大显身手了。有了它，就不需要自己手动在组件上绑定监听当前实例上的自定义事件，会使代码更简洁。</span></span></p><p>下面以一个 <code>input</code> 组件实现的核心代码，介绍下 <code>v-model</code> 的应用。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!--父组件--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;base-input v-model=<span class="string">"input"</span>&gt;&lt;<span class="regexp">/base-input&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        data() &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                input: <span class="string">''</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">&lt;!--子组件--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> :value=<span class="string">"currentValue"</span>  @input=<span class="string">"handleInput"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    export default &#123;</span></span><br><span class="line"><span class="regexp">        data() &#123;</span></span><br><span class="line"><span class="regexp">            return &#123;</span></span><br><span class="line"><span class="regexp">                currentValue: this.value === undefined || this.value === null ? ''</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &#125;,</span></span><br><span class="line"><span class="regexp">        props: &#123;</span></span><br><span class="line"><span class="regexp">            value: [String, Number],</span></span><br><span class="line"><span class="regexp">        &#125;,</span></span><br><span class="line"><span class="regexp">        methods: &#123;</span></span><br><span class="line"><span class="regexp">            handleInput(event) &#123;</span></span><br><span class="line"><span class="regexp">                const value = event.target.value;</span></span><br><span class="line"><span class="regexp">                this.$emit('input', value);</span></span><br><span class="line"><span class="regexp">            &#125;,</span></span><br><span class="line"><span class="regexp">        &#125;,</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure></div><p>有时，在某些特定的控件中名为 <code>value</code> 的属性会有特殊的含义，这时可以通过 <code>model</code> 选项来回避这种冲突。</p><h3 id="sync-修饰符"><a href="#sync-修饰符" class="headerlink" title="sync 修饰符"></a>sync 修饰符</h3><p><code>.sync</code> 修饰符在 vue 1.x 的版本中就已经提供，1.x 版本中，当子组件改变了一个带有 <code>.sync</code> 的 <code>prop</code> 的值时，会将这个值同步到父组件中的值。这样使用起来十分方便，但问题也十分明显，这样破坏了单向数据流，当应用复杂时，debug 的成本会非常高。</p><p>于是乎，在 vue 2.0 中移除了 <code>.sync</code>。但是在实际的应用中，<code>.sync</code> 是有它的应用场景的，所以在 vue 2.3 版本中，又迎来了全新的 <code>.sync</code>。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">&lt;text-<span class="built_in">document</span></span><br><span class="line">  v-bind:title=<span class="string">"doc.title"</span></span><br><span class="line">  v-on:update:title=<span class="string">"doc.title = $event"</span></span><br><span class="line">&gt;&lt;<span class="regexp">/text-document&gt;</span></span><br></pre></td></tr></table></figure></div><p>上面的代码，使用 <code>.sync</code> 就可以写成</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">&lt;text-<span class="built_in">document</span> v-bind:title.sync=<span class="string">"doc.title"</span>&gt;&lt;<span class="regexp">/text-document&gt;</span></span><br></pre></td></tr></table></figure></div><p>这样，在子组件中，就可以通过下面代码来实现对这个 <code>prop</code> 重新赋值的意图了。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'update:title'</span>, newTitle)</span><br></pre></td></tr></table></figure></div><ul><li>v-model 和 .sync 对比</li></ul><blockquote><p><code>.sync</code> 从功能上看和 <code>v-model</code> 十分相似，都是为了实现数据的“双向绑定”，本质上，也都不是真正的双向绑定，而是语法糖。<br>相比较之下，<code>.sync</code> 更加灵活，它可以给多个 prop 使用，而 <code>v-model</code> 在一个组件中只能有一个。<br>从语义上来看，<code>v-model</code> 绑定的值是指这个组件的绑定值，比如 input 组件，select 组件，日期时间选择组件，颜色选择器组件，这些组件所绑定的值使用 <code>v-model</code> 比较合适。其他情况，没有这种语义，个人认为使用 .sync 更好。</p></blockquote><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>ref 特性可以为子组件赋予一个 ID 引用，通过这个 ID 引用可以直接访问这个子组件的实例。当父组件中需要主动获取子组件中的数据或者方法时，可以使用 <code>$ref</code> 来获取。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">&lt;!--父组件--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;base-input ref=<span class="string">"baseInput"</span>&gt;&lt;<span class="regexp">/base-input&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        methods: &#123;</span><br><span class="line">        focusInput: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.$refs.usernameInput.focus()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!--子组件--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;input ref=<span class="string">"input"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    export default &#123;</span></span><br><span class="line"><span class="regexp">    methods: &#123;</span></span><br><span class="line"><span class="regexp">        focus: function () &#123;</span></span><br><span class="line"><span class="regexp">            this.$refs.input.focus()</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure></div><p>使用 ref 时，有两点需要注意</p><blockquote><ol><li><code>$refs</code> 是作为渲染结果被创建的，所以在初始渲染的时候它还不存在，此时无法无法访问。</li><li><code>$refs</code> 不是响应式的，只能拿到获取它的那一刻子组件实例的状态，所以要避免在模板和计算属性中使用它。</li></ol></blockquote><h3 id="parent-和-children"><a href="#parent-和-children" class="headerlink" title="$parent 和 $children"></a>$parent 和 $children</h3><p><code>$parent</code> 属性可以用来从一个子组件访问父组件的实例，<code>$children</code> 属性 可以获取当前实例的直接子组件。</p><p>看起来使用 <code>$parent</code> 比使用 prop 传值更加简单灵活，可以随时获取父组件的数据或方法，又不像使用 prop 那样需要提前定义好。但使用 <code>$parent</code> 会导致父组件数据变更后，很难去定位这个变更是从哪里发起的，所以在绝大多数情况下，不推荐使用。</p><p>在有些场景下，两个组件之间可能是父子关系，也可能是更多层嵌套的祖孙关系,这时就可以使用 <code>$parent</code>。</p><p>下面是 element ui 中的组件 el-radio-group 和 组件 el-radio 使用示例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-radio-group v-model=<span class="string">"radio1"</span>&gt;</span><br><span class="line">    &lt;el-radio :label=<span class="string">"3"</span>&gt;备选项&lt;<span class="regexp">/el-radio&gt;</span></span><br><span class="line"><span class="regexp">    &lt;component-1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;el-radio :label="3"&gt;备选项&lt;/</span>el-radio&gt;</span><br><span class="line">    &lt;<span class="regexp">/component-1&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>el-radio-group&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  export default &#123;</span></span><br><span class="line"><span class="regexp">    data () &#123;</span></span><br><span class="line"><span class="regexp">      return &#123;</span></span><br><span class="line"><span class="regexp">        radio2: 3</span></span><br><span class="line"><span class="regexp">      &#125;;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure></div><p>在 el-radio-group 和 组件 el-radio 通信中， 组件 el-radio 的 value 值需要和 el-radio-group 的 <code>v-model</code> 的值进行“绑定”，我们就可以在 el-radio 内借助 <code>$parent</code> 来访问到 el-radio-group 的实例，来获取到 el-radio-group 中 <code>v-model</code> 绑定的值。</p><p>下面是获取 el-radio 组件中获取 el-radio-group 实例的源码：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// el-radio组件</span></span><br><span class="line"><span class="keyword">let</span> parent = <span class="keyword">this</span>.$parent</span><br><span class="line"><span class="keyword">while</span> (parent) &#123;</span><br><span class="line">  <span class="keyword">if</span> (parent.$options.componentName !== <span class="string">'ElRadioGroup'</span>) &#123;</span><br><span class="line">    parent = parent.$parent</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._radioGroup = parent <span class="comment">// this._radioGroup 为组件 el-radio-group 的实例</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="二、非父子组件通信"><a href="#二、非父子组件通信" class="headerlink" title="二、非父子组件通信"></a>二、非父子组件通信</h2><h3 id="attrs-和-listeners"><a href="#attrs-和-listeners" class="headerlink" title="$attrs 和 $listeners"></a>$attrs 和 $listeners</h3><p>当要和一个嵌套很深的组件进行通信时，如果使用 <code>prop</code> 和 <code>events</code> 就会显的十分繁琐，中间的组件只起到了一个中转站的作用，像下面这样：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">&lt;!--父组件--&gt;</span><br><span class="line">  &lt;parent-component :message=<span class="string">"message"</span>&gt;我是父组件&lt;<span class="regexp">/parent-component&gt;</span></span><br><span class="line"><span class="regexp">&lt;!--子组件--&gt;</span></span><br><span class="line"><span class="regexp">  &lt;child-component :message="message"&gt;我是子组件&lt;/</span>child-component&gt;</span><br><span class="line">&lt;!--孙子组件--&gt;</span><br><span class="line">  &lt;grand-child-component :message=<span class="string">"message"</span>&gt;我是孙子组件&lt;<span class="regexp">/grand-child-component&gt;</span></span><br></pre></td></tr></table></figure></div><p>当要传递的数据很多时，就需要在中间的每个组件都重复写很多遍，反过来从后代组件向祖先组件使用 <code>events</code> 传递也会有同样的问题。使用 <code>$attrs</code> 和 <code>$listeners</code>就可以简化这样的写法。</p><p><code>$attrs</code> 会包含父组件中没有被 <code>prop</code> 接收的所有属性（不包含 class 和 style 属性），可以通过 <code>v-bind=&quot;$attrs&quot;</code> 直接将这些属性传入内部组件。</p><p><code>$listeners</code> 会包含所有父组件中的 <code>v-on</code> 事件监听器 (不包含 · 修饰器的) ，可以通过 <code>v-on=&quot;$listeners&quot;</code> 传入内部组件。</p><p>下面以父组件和孙子组件的通信为例介绍它们的使用:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">&lt;!--父组件 parent.vue--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;child :name=<span class="string">"name"</span> :message=<span class="string">"message"</span> @sayHello=<span class="string">"sayHello"</span>&gt;&lt;<span class="regexp">/child&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name: <span class="string">'通信'</span>,</span><br><span class="line">            message: <span class="string">'Hi'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        sayHello(mes) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'mes'</span>, mes) <span class="comment">// =&gt; "hello"</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">&lt;!--子组件 child.vue--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;grandchild v-bind=<span class="string">"$attrs"</span> v-on=<span class="string">"$listeners"</span>&gt;&lt;<span class="regexp">/grandchild&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        name,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">&lt;!--孙子组件 grand-child.vue--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">    created() &#123;</span></span><br><span class="line"><span class="regexp">        this.$emit('sayHello', 'hello')</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure></div><h3 id="provide-和-inject"><a href="#provide-和-inject" class="headerlink" title="provide 和 inject"></a>provide 和 inject</h3><p><code>provide</code> 和 <code>inject</code> 需要在一起使用，它可以使一个祖先组件向其所有子孙后代注入一个依赖，可以指定想要提供给后代组件的数据/方法，不论组件层次有多深，都能够使用。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">&lt;!--祖先组件--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    provide: &#123;</span><br><span class="line">        author: <span class="string">'yushihu'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">&lt;!--子孙组件--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    inject: [<span class="string">'author'</span>],</span><br><span class="line">    created() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'author'</span>, <span class="keyword">this</span>.author) <span class="comment">// =&gt; yushihu</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></div><p><code>provide</code> 和 <code>inject</code> 绑定不是响应的，它被设计是为组件库和高阶组件服务的，平常业务中的代码不建议使用。</p><h3 id="dispatch-和-broadcast"><a href="#dispatch-和-broadcast" class="headerlink" title="dispatch 和 broadcast"></a>dispatch 和 broadcast</h3><p>vue 在 2.0 版本就已经移除了 <code>$dispatch</code> 和 <code>$broadcast</code>，因为这种基于组件树结构的事件流方式会在组件结构扩展的过程中会变得越来越难维护。但在某些不使用 vuex 的情况下，仍然有使用它们的场景。所以 element ui 和 iview 等开源组件库中对 <code>broadcast</code> 和 <code>dispatch</code> 方法进行了重写，并通过 mixin 的方式植入到每个组件中。</p><p>实现 <code>dispatch</code> 和 <code>broadcast</code> 主要利用我们上面已经说过的 <code>$parent</code> 和 <code>$children</code>。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//element ui 中重写 broadcast 的源码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">broadcast</span>(<span class="params">componentName, eventName, params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name = child.$options.componentName</span><br><span class="line">    <span class="keyword">if</span> (name === componentName) &#123;</span><br><span class="line">      child.$emit.apply(child, [eventName].concat(params))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      broadcast.apply(child, [componentName, eventName].concat([params]))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><code>broadcast</code> 方法的作用是向后代组件传值，它会遍历所有的后代组件，如果后代组件的 <code>componentName</code> 与当前的组件名一致，则触发 <code>$emit</code> 事件，将数据 <code>params</code> 传给它。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//element ui 中重写 dispatch 的源码</span></span><br><span class="line">dispatch(componentName, eventName, params) &#123;</span><br><span class="line">  <span class="keyword">var</span> parent = <span class="keyword">this</span>.$parent || <span class="keyword">this</span>.$root;</span><br><span class="line">  <span class="keyword">var</span> name = parent.$options.componentName;</span><br><span class="line">  <span class="keyword">while</span> (parent &amp;&amp; (!name || name !== componentName)) &#123;</span><br><span class="line">	parent = parent.$parent;</span><br><span class="line">	<span class="keyword">if</span> (parent) &#123;</span><br><span class="line">	  name = parent.$options.componentName;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">	parent.$emit.apply(parent, [eventName].concat(params));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><code>dispatch</code> 的作用是向祖先组件传值，它会一直寻找父组件，直到找到组件名和当前传入的组件名一致的祖先组件，就会触发其身上的 <code>$emit</code> 事件，将数据传给它。这个寻找对应的父组件的过程和文章前面讲解 <code>$parent</code> 的例子类似。</p><h3 id="eventBus"><a href="#eventBus" class="headerlink" title="eventBus"></a>eventBus</h3><p>对于比较小型的项目，没有必要引入 <code>vuex</code> 的情况下，可以使用 <code>eventBus</code>。相比我们上面说的所有通信方式，<code>eventBus</code> 可以实现任意两个组件间的通信。</p><p>它的实现思想也很好理解，在要相互通信的两个组件中，都引入同一个新的 vue 实例，然后在两个组件中通过分别调用这个实例的事件触发和监听来实现通信。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eventBus.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vue()</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">&lt;!--组件A--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> Bus <span class="keyword">from</span> <span class="string">'eventBus.js'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        sayHello() &#123;</span><br><span class="line">            Bus.$emit(<span class="string">'sayHello'</span>, <span class="string">'hello'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">&lt;!--组件B--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> Bus <span class="keyword">from</span> <span class="string">'eventBus.js'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    created() &#123;</span><br><span class="line">        Bus.$on(<span class="string">'sayHello'</span>, target =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(target);  <span class="comment">// =&gt; 'hello'</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></div><h3 id="通过-root-访问根实例"><a href="#通过-root-访问根实例" class="headerlink" title="通过 $root 访问根实例"></a>通过 $root 访问根实例</h3><p>通过 <code>$root</code>，任何组件都可以获取当前组件树的根 Vue 实例，通过维护根实例上的 <code>data</code>，就可以实现组件间的数据共享。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js 根实例</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  store,</span><br><span class="line">  router,</span><br><span class="line">  <span class="comment">// 根实例的 data 属性，维护通用的数据</span></span><br><span class="line">  data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      author: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">&lt;!--组件A--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    created() &#123;</span><br><span class="line">        <span class="keyword">this</span>.$root.author = <span class="string">'于是乎'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">&lt;!--组件B--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>远方<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#123;&#123; $root.author &#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br></pre></td></tr></table></figure></div><p>通过这种方式，虽然可以实现通信，但在应用的任何部分，任何时间发生的任何数据变化，都不会留下变更的记录，这对于稍复杂的应用来说，调试是致命的，不建议在实际应用中使用。</p><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p><span style="color:#f60">Vuex</span> 是一个专为 <code>Vue.js</code> 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><p>图片引用自网络:</p><p><img src="http://blog.yptup.top/vuex.webp" alt="Vuex"></p><p><a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">Vuex 的具体使用方式</a></p><h3 id="自己实现简单的-Store-模式"><a href="#自己实现简单的-Store-模式" class="headerlink" title="自己实现简单的 Store 模式"></a>自己实现简单的 Store 模式</h3><p>对于小型的项目，通信十分简单，这时使用 Vuex 反而会显得冗余和繁琐，这种情况最好不要使用 Vuex，可以自己在项目中实现简单的 Store。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//store.js</span></span><br><span class="line"><span class="keyword">var</span> store = &#123;</span><br><span class="line">  debug: <span class="literal">true</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    author: <span class="string">'yushihu!'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  setAuthorAction(newValue) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.debug) <span class="built_in">console</span>.log(<span class="string">'setAuthorAction triggered with'</span>, newValue)</span><br><span class="line">    <span class="keyword">this</span>.state.author = newValue</span><br><span class="line">  &#125;,</span><br><span class="line">  deleteAuthorAction() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.debug) <span class="built_in">console</span>.log(<span class="string">'deleteAuthorAction triggered'</span>)</span><br><span class="line">    <span class="keyword">this</span>.state.author = <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>和 <code>Vuex</code> 一样，<code>store</code> 中 <code>state</code> 的改变都由 store 内部的 <code>action</code> 来触发，并且能够通过 <code>log</code> 保留触发的痕迹。这种方式十分适合在不需要使用 <code>Vuex</code> 的小项目中应用。</p><p>与 <code>$root</code> 访问根实例的方法相比，这种集中式状态管理的方式能够在调试过程中，通过 <code>log</code> 记录来确定当前变化是如何触发的，更容易定位问题。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JS数组常用技巧</title>
    <url>/posts/133a37.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 02 2020 23:48:26 GMT+0800 (GMT+08:00) --><p><canter>你必须知道的 JS 数组技巧</canter></p><p>在 Javascript 中，数组是一个重要且常见的知识点，我们经常将数据存储在数组中。作为一名 Javascript 工程师，数组必须要运用自如。这篇文章，向大家展示了在日常开发中，数组有哪些奇淫技巧值得关注和学习，让我们开始吧！</p><a id="more"></a><h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><p>怎么对 JS 的数组去重。在 ES6 的时代，有个非常快速且简单的方法，使用<code>new Set()</code>以及<code>Array.from()</code>或者<code>展开运算符(...)</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">'banana'</span>, <span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'watermelon'</span>, <span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'grape'</span>, <span class="string">'apple'</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">var</span> uniqueFruits = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(fruits));</span><br><span class="line"><span class="built_in">console</span>.log(uniqueFruits); <span class="comment">// returns ['banana', 'apple', 'orange', 'watermelon', 'grape']</span></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">var</span> uniqueFruits2 = […<span class="keyword">new</span> <span class="built_in">Set</span>(fruits)];</span><br><span class="line"><span class="built_in">console</span>.log(uniqueFruits2); <span class="comment">// returns ['banana', 'apple', 'orange', 'watermelon', 'grape']</span></span><br></pre></td></tr></table></figure></div><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>日常开发中经常需要替换或者删除一些指定的数据，遇到这种场景时一定要联想到<code>Array.protoType.splice</code>这个方法。传参时稍微复杂点，第一个参数是开始的索引，第二个参数是需要删除的数量，剩下的就是需要添加的值（可以是一个或者多个）。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [</span><br><span class="line">  <span class="string">'banana'</span>,</span><br><span class="line">  <span class="string">'apple'</span>,</span><br><span class="line">  <span class="string">'orange'</span>,</span><br><span class="line">  <span class="string">'watermelon'</span>,</span><br><span class="line">  <span class="string">'apple'</span>,</span><br><span class="line">  <span class="string">'orange'</span>,</span><br><span class="line">  <span class="string">'grape'</span>,</span><br><span class="line">  <span class="string">'apple'</span></span><br><span class="line">]</span><br><span class="line">fruits.splice(<span class="number">0</span>, <span class="number">2</span>, <span class="string">'potato'</span>, <span class="string">'tomato'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(fruits) <span class="comment">// returns ['potato', 'tomato', 'orange', 'watermelon', 'apple', 'orange', 'grape', 'apple']</span></span><br></pre></td></tr></table></figure></div><h2 id="清空数组"><a href="#清空数组" class="headerlink" title="清空数组"></a>清空数组</h2><p>有时我们需要清空一个数组，比如用户点击了清空购物车。可以一条一条地删除，但是很少有这么可爱的程序员，哈哈。其实一行代码就能搞定，那就是直接将之 length 设置成 0</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [</span><br><span class="line">  <span class="string">'banana'</span>,</span><br><span class="line">  <span class="string">'apple'</span>,</span><br><span class="line">  <span class="string">'orange'</span>,</span><br><span class="line">  <span class="string">'watermelon'</span>,</span><br><span class="line">  <span class="string">'apple'</span>,</span><br><span class="line">  <span class="string">'orange'</span>,</span><br><span class="line">  <span class="string">'grape'</span>,</span><br><span class="line">  <span class="string">'apple'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">fruits.length = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(fruits) <span class="comment">// returns []</span></span><br></pre></td></tr></table></figure></div><h2 id="数组转换成对象"><a href="#数组转换成对象" class="headerlink" title="数组转换成对象"></a>数组转换成对象</h2><p>有时候需要将数组转换成对象的形式，使用<code>.map()</code>一类的迭代方法能达到目的，这里还有个更快的方法，前提是你正好希望对象的 key 就是数组的索引</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">'banana'</span>, <span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'watermelon'</span>];</span><br><span class="line"><span class="keyword">var</span> fruitsObj = &#123; …fruits &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(fruitsObj); <span class="comment">// returns &#123;0: 'banana', 1: 'apple', 2: 'orange', 3: 'watermelon', 4: 'apple', 5: 'orange', 6: 'grape', 7: 'apple'&#125;</span></span><br></pre></td></tr></table></figure></div><h2 id="填充数组"><a href="#填充数组" class="headerlink" title="填充数组"></a>填充数组</h2><p>创建数组的时候，你有没有遇到过需要填充上默认值的场景，你肯定首先想到的就是循环这个数组。ES6 提供了更便捷的<code>fill</code>方法</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newArray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>).fill(<span class="string">'1'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(newArray) <span class="comment">// returns ['1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1']</span></span><br></pre></td></tr></table></figure></div><h2 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h2><p>你知道如何合并数组吗，答案就是<code>concat()</code>。哈哈，但是今天的主角是 ES6 的展开运算符<code>(...)</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'orange'</span>];</span><br><span class="line"><span class="keyword">var</span> meat = [<span class="string">'poultry'</span>, <span class="string">'beef'</span>, <span class="string">'fish'</span>];</span><br><span class="line"><span class="keyword">var</span> vegetables = [<span class="string">'potato'</span>, <span class="string">'tomato'</span>, <span class="string">'cucumber'</span>];</span><br><span class="line"><span class="keyword">var</span> food = […fruits, …meat, …vegetables];</span><br><span class="line"><span class="built_in">console</span>.log(food); <span class="comment">// ['apple', 'banana', 'orange', 'poultry', 'beef', 'fish', 'potato', 'tomato', 'cucumber']</span></span><br></pre></td></tr></table></figure></div><h2 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h2><p>方法很多，这里直接上最简洁的方法</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numOne = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">var</span> numTwo = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> duplicatedValues = […<span class="keyword">new</span> <span class="built_in">Set</span>(numOne)].filter(<span class="function"><span class="params">item</span> =&gt;</span> numTwo.includes(item));</span><br><span class="line"><span class="built_in">console</span>.log(duplicatedValues); <span class="comment">// returns [2, 4, 6]</span></span><br></pre></td></tr></table></figure></div><h2 id="去除假值"><a href="#去除假值" class="headerlink" title="去除假值"></a>去除假值</h2><p>首先，我们熟悉下假值<code>(falsy values)</code>是什么？在 JS 中，假值有：<code>false、0、&#39;&#39;、null、NaN、undefined</code>。现在我们找到这些假值并将它们移除，这里使用的是<code>filter</code>方法</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mixedArr = [<span class="number">0</span>, <span class="string">'blue'</span>, <span class="string">''</span>, <span class="literal">NaN</span>, <span class="number">9</span>, <span class="literal">true</span>, <span class="literal">undefined</span>, <span class="string">'white'</span>, <span class="literal">false</span>]</span><br><span class="line"><span class="keyword">var</span> trueArr = mixedArr.filter(<span class="built_in">Boolean</span>)</span><br><span class="line"><span class="built_in">console</span>.log(trueArr) <span class="comment">// returns ['blue', 9, true, 'white']</span></span><br></pre></td></tr></table></figure></div><h2 id="随机值"><a href="#随机值" class="headerlink" title="随机值"></a>随机值</h2><p>从数组中获取随机的一个值，核心知识是随机生成一个值 x,x &gt;= 0 并且 x &lt; 数组的 length</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [</span><br><span class="line">  <span class="string">'blue'</span>,</span><br><span class="line">  <span class="string">'white'</span>,</span><br><span class="line">  <span class="string">'green'</span>,</span><br><span class="line">  <span class="string">'navy'</span>,</span><br><span class="line">  <span class="string">'pink'</span>,</span><br><span class="line">  <span class="string">'purple'</span>,</span><br><span class="line">  <span class="string">'orange'</span>,</span><br><span class="line">  <span class="string">'yellow'</span>,</span><br><span class="line">  <span class="string">'black'</span>,</span><br><span class="line">  <span class="string">'brown'</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">var</span> randomColor = colors[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * colors.length)]</span><br></pre></td></tr></table></figure></div><h2 id="倒序"><a href="#倒序" class="headerlink" title="倒序"></a>倒序</h2><p>怎么对数组进行倒序？只需要一行代码</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [</span><br><span class="line">  <span class="string">'blue'</span>,</span><br><span class="line">  <span class="string">'white'</span>,</span><br><span class="line">  <span class="string">'green'</span>,</span><br><span class="line">  <span class="string">'navy'</span>,</span><br><span class="line">  <span class="string">'pink'</span>,</span><br><span class="line">  <span class="string">'purple'</span>,</span><br><span class="line">  <span class="string">'orange'</span>,</span><br><span class="line">  <span class="string">'yellow'</span>,</span><br><span class="line">  <span class="string">'black'</span>,</span><br><span class="line">  <span class="string">'brown'</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">var</span> reversedColors = colors.reverse()</span><br><span class="line"><span class="comment">// 或者 colors.slice().reverse();</span></span><br><span class="line"><span class="comment">// 两者有啥区别？</span></span><br><span class="line"><span class="built_in">console</span>.log(reversedColors) <span class="comment">// returns ['brown', 'black', 'yellow', 'orange', 'purple', 'pink', 'navy', 'green', 'white', 'blue']</span></span><br></pre></td></tr></table></figure></div><h2 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h2><p>很多时候我们查找元素是否存在于某个数组中，经常使用<code>indexOf</code>方法，常常忽略<code>lastIndexOf</code>方法，后者会被使用的一个场景就是，某个数组中有重复的数据。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">var</span> lastIndex = nums.lastIndexOf(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(lastIndex) <span class="comment">// returns 9</span></span><br></pre></td></tr></table></figure></div><h2 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h2><p>答案也是很多，条条大道通罗马，这里使用的是<code>reduce</code>，<code>reduce</code>方法是很值得学习的知识点，用处很多。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">var</span> sum = nums.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y)</span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">// returns 14</span></span><br></pre></td></tr></table></figure></div><p>本文主要列举了一些简洁的方法，实现方法很多，不在此一一列举<br>未完待续…</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>页面性能优化</title>
    <url>/posts/d333b549.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 02 2020 23:48:26 GMT+0800 (GMT+08:00) --><p><canter>优化前端性能，提升用户体验，一直是从事前端工作人员必须考虑的问题，之前参考过很多资料，大多说的不是很详细，重点描述的也不是很到位，鄙人不才，愿集百家之所长，供大家参考(其实大概意思就是本文非本人原创，都是参考自别人的资料，由于资源来自四面八方，就不在这里一一列举了)</canter></p><a id="more"></a><h2 id="性能优化概述"><a href="#性能优化概述" class="headerlink" title="性能优化概述"></a>性能优化概述</h2><p><strong>从输入 URL 到页面加载完成，完整的链路</strong></p><p><img src="http://blog.yptup.top/gaishu.webp" alt></p><ol><li>DNS 解析</li><li>TCP 连接</li><li>HTTP 请求抛出</li><li>服务端处理请求，HTTP 响应返回</li><li>浏览器拿到响应数据，解析响应内容，把解析的结果展示给用户</li></ol><h2 id="整个性能消化"><a href="#整个性能消化" class="headerlink" title="-整个性能消化"></a>-整个性能消化</h2><p><img src="http://blog.yptup.top/xingneng.webp" alt></p><h2 id="HTTP-层面优化"><a href="#HTTP-层面优化" class="headerlink" title="HTTP 层面优化"></a>HTTP 层面优化</h2><ul><li>DNS 解析:<br>DNS 实现域名到 IP 的映射。通过域名访问站点，每次请求都要做 DNS 解析。目前每次 DNS 解析，通常在 200ms 以下。一般采用 DNS Prefetch 一种 DNS 预解析技术，当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行 DNS 的解析，减少用户等待时间，提高用户体验。</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"dns-prefetch"</span> href=<span class="string">"www.baidu.com"</span> /&gt;</span><br><span class="line"><span class="comment">// 只支持部分浏览器</span></span><br></pre></td></tr></table></figure></div><ul><li><p>TCP 连接：<br>采用 http2.0，可以复用 tcp 通道，采用二进制格式而非文本格式，使用报头压缩，HTTP/2 降低了开销，支持 cache push</p></li><li><p>浏览器并发<br>基于端口跟线程切换开销，浏览器不可能无限的并发请求。chrome 的并发为 6，超过限制数目的请求就会被阻塞；<br>对于某些静态资源，图片等等，我们可以对其 URL 分散处理 ，不同的资源域名(部署在 cdn 上)。</p></li><li><p>http 请求次数<br>减少 http 的请求次数，将多个请求合并成同一个，减少 http 的开销</p></li><li><p>webpack<br>充分利用 webpack 提供给我们的能力，利用 DllPlugin 与 commonPlugins 等插件对我们代码进行<br>优化，文件的分割与合并，公共代码的提取，长缓存等策略</p></li><li><p>HTTP 压缩<br>采用 Gzip 压缩：HTTP 压缩就是以缩小体积为目的，对 HTTP 内容进行重新编码的过程，原理是找出一些重复出现的字符串、临时替换它们，从而使整个文件变小，文件中代码的重复率越高，那么压缩的效率就越高，使用 Gzip 的收益也就越大</p></li></ul><h2 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h2><p><img src="http://blog.yptup.top/img.webp" alt></p><h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><ul><li>强缓存：<br>浏览器在请求某一资源时，会先获取该资源缓存的 header 信息，判断是否命中强缓存（cache-control 和 expires 信息），若命中直接从缓存中获取资源信息，包括缓存 header 信息；本次请求根本就不会与服务器进行通信</li></ul><ol><li><p>expires:这是 http1.0 时的规范；它的值为一个绝对时间的 GMT 格式的时间字符串，如 Mon, 10 Jun 2015 21:31:12 GMT，如果发送请求的时间在 expires 之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源</p></li><li><p>cache-control：max-age=number，这是 http1.1 时出现的 header 信息，主要是利用该字段的 max-age 值来进行判断，它是一个相对值；资源第一次的请求时间和 Cache-Control 设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；cache-control 除了该字段外，还有下面几个比较常用的设置值：no-cache ，no-store，public，private</p></li></ol><ul><li>协商缓存（对比缓存）</li></ul><ol><li>Last-Modified/If-Modified-Since:第一次请求，服务端在 Response Headers ：Last-Modified:Fri, 27 Oct 2017 06:35:57 GMT，也就是服务端最后修改该资源的时间。浏览器再次跟服务器请求这个资源时，会在 request 的 header 上加上 If-Modified-Since 的 header，这个 header 的值就是上一次请求时返回的 Last-Modified 的值，服务器进行比较，如果相同则返回 304，否则浏览器直接从服务器加载资源时，Last-Modified 的 Header 在重新加载的时候会被更新，下次请求时，If-Modified-Since 会启用上次返回的 Last-Modified 值</li><li>Etag/If-None-Match: 服务器会为每个资源生成一个唯一的标识字符串，只要文件内容不同，它们对应的 Etag 就是不同的；If-Modified-Since 能检查到的精度是 s 级的，某些服务器不能精确的得到文件的最后修改时间，我们编辑了文件，但文件的内容没有改变。因为服务器是根据文件的最后修改时间来判断的，导致重新请求所以才出现了 Etag，Etag 对服务器也有性能损耗</li></ol><blockquote><p>Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。</p></blockquote><ul><li>请求过程总结：<br><img src="http://blog.yptup.top/modified.webp" alt></li></ul><h2 id="浏览器渲染机制"><a href="#浏览器渲染机制" class="headerlink" title="浏览器渲染机制"></a>浏览器渲染机制</h2><ul><li><p>DOM 树:<br>解析 HTML 以创建的是 DOM 树（DOM tree ）：渲染引擎开始解析 HTML 文档，转换树中的标签到 DOM 节点，它被称为“内容树”。</p></li><li><p>CSSOM 树：<br>解析 CSS（包括外部 CSS 文件和样式元素）创建的是 CSSOM 树。CSSOM 的解析过程与 DOM 的解析过程是并行的。</p></li><li><p>渲染树：<br>CSSOM 与 DOM 结合，之后我们得到的就是渲染树（Render tree ）。</p></li><li><p>布局渲染树：<br>从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕上的精确坐标，我们便得到了基于渲染树的布局渲染树（Layout of the render tree）。</p></li><li><p>绘制渲染树:<br>遍历渲染树，每个节点将使用 UI 后端层来绘制。整个过程叫做绘制渲染树（Painting the render tree）。</p></li></ul><center class="color-ccc">渲染流程图</center><p><img src="http://blog.yptup.top/Image.png" alt></p><h2 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h2><ul><li>普通模式，JS 会阻塞浏览器，浏览器必须等待 index.js 加载和执⾏完毕才能去做其它事情。一般将此类 js 放在在<code>body</code>标签的底部，减少对整个页面下载的影响</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"index.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></div><ul><li>async 模式：JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会立即执行，async 模式没有执行顺序，先返回的优先执行，先到先得</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">"index.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></div><ul><li>defer 模式：JS 的加载是异步的，执行是被推迟的。等整个文档解析完成 DOMContentLoaded 事件即将被触发时，被标记了 defer 的 JS 文件才会开始依次执行</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">&lt;script defer src=<span class="string">"index.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></div><p>一般当我们的脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。</p><ul><li>动态加载脚本：此文件当元素添加到页面之后立刻开始下载。无论在何处启动下载，文件的下载和运行都不会阻塞其他页面处理过程。甚至可以将这些代码放在<head>部分而不会对其余部分的页面代码造成影响</head></li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">script.type = <span class="string">'text/javascript'</span></span><br><span class="line">script.src = <span class="string">'script1.js'</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(script)</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3 transform 中的坑</title>
    <url>/posts/f4adc94f.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 02 2020 23:48:26 GMT+0800 (GMT+08:00) --><p>transform 对普通元素的影响是个巨坑，自己亲身体验的总共有三点</p><blockquote><ol><li>提升元素的垂直地位，也就是 z-index 会变大</li><li>改变元素的定位属性，fixed 变成 absolute，absolute 变成 relative</li><li>使绝对定位(absolute)的子元素受父元素 overflow:hidden 的作用。（ps:绝对定位(absolute)的子元素宽度大于父元素，如果父容器的定位是 static，也就是默认时，overflow:hidden 无效）</li></ol></blockquote><p style="color:red">下面我们来看一下没有没有transform属性的状态</p><p><img src="/posts/f4adc94f/no-transform.png" alt="no-transform"></p><p>再来看一下给红色框增加 transform 属性后的状态</p><p><img src="/posts/f4adc94f/transform.png" alt="transform"></p><p>注:<br>CSS3 新增的一些属性虽然才艺高超，但是在非必要的情况下，还是尽量不要用它<br>CSS3 虽好，但是不要贪杯哦</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端踩坑记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue生命周期详解</title>
    <url>/posts/6f7db675.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 02 2020 23:48:26 GMT+0800 (GMT+08:00) --><p>Vue 实例有一个完整的生命周期，也就是说从开始创建、初始化数据、编译模板、挂在 DOM、渲染-更新-渲染、卸载等一系列过程，我们成为 Vue 实例的生命周期，钩子就是在某个阶段给你一个做某些处理的机会。</p><a id="more"></a><p><img src="http://blog.yptup.top/vue.webp" alt="生命周期图"></p><center><font color="#ccc">生命周期图</font></center><hr><p><img src="/posts/6f7db675/vue2.jpg" alt></p><ul><li><p>beforeCreate(创建前)<br>在实例初始化之后，数据观测和事件配置之前被调用，此时组件的选项对象还未创建，el 和 data 并未初始化，因此无法访问 methods， data， computed 等上的方法和数据。</p></li><li><p>created(创建后)<br>实例已经创建完成之后被调用，在这一步，实例已完成以下配置：数据观测、属性和方法的运算，watch/event 事件回调，完成了 data 数据的初始化，el 没有。 然而，挂在阶段还没有开始, $el 属性目前不可见，这是一个常用的生命周期，因为你可以调用 methods 中的方法，改变 data 中的数据，并且修改可以通过 vue 的响应式绑定体现在页面上，，获取 computed 中的计算属性等等，通常我们可以在这里对实例进行预处理，也有一些童鞋喜欢在这里发 ajax 请求，值得注意的是，这个周期中是没有什么方法来对实例化过程进行拦截的，因此假如有某些数据必须获取才允许进入页面的话，并不适合在这个方法发请求，建议在组件路由钩子 beforeRouteEnter 中完成</p></li><li><p>beforeMount<br>挂在开始之前被调用，相关的 render 函数首次被调用（虚拟 DOM），实例已完成以下的配置： 编译模板，把 data 里面的数据和模板生成 html，完成了 el 和 data 初始化，注意此时还没有挂在 html 到页面上。</p></li><li><p>mounted<br>挂在完成，也就是模板中的 HTML 渲染到 HTML 页面中，此时一般可以做一些 ajax 操作，mounted 只会执行一次。</p></li><li><p>beforeUpdate<br>在数据更新之前被调用，发生在虚拟 DOM 重新渲染和打补丁之前，可以在该钩子中进一步地更改状态，不会触发附加地重渲染过程</p></li><li><p>updated(更新后)<br>在由于数据更改导致地虚拟 DOM 重新渲染和打补丁之后调用，调用时，组件 DOM 已经更新，所以可以执行依赖于 DOM 的操作，然后在大多是情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环，该钩子在服务器端渲染期间不被调用</p></li><li><p>beforeDestrioy(销毁前)<br>在实例销毁之前调用，实例仍然完全可用，</p></li></ul><ol><li>这一步还可以用 this 来获取实例</li><li>一般在这一步做一些重置的操作，比如清除掉组件中的定时器 和 监听的 dom 事件</li></ol><ul><li>destroyed(销毁后)<br>在实例销毁之后调用，调用后，所以的事件监听器会被移出，所有的子实例也会被销毁，该钩子在服务器端渲染期间不被调用</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>构造函数</title>
    <url>/posts/1688ec4d.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 02 2020 23:48:26 GMT+0800 (GMT+08:00) --><p>摘要内容</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数是一种特殊的函数，主要用来初始化对象，即为对<br>象成员变量赋初始值，它总与 new 一起使用。我们可以把对象<br>中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</p><a id="more"></a><p>在 JS 中，使用构造函数时要注意以下两点：</p><ul><li>构造函数用于创建某一类对象，其首字母要大写</li><li>构造函数要和 new 一起使用才有意义</li></ul><h3 id="new-在执行时会做四件事情"><a href="#new-在执行时会做四件事情" class="headerlink" title="new 在执行时会做四件事情"></a>new 在执行时会做四件事情</h3><ul><li>在内存中创建一个新的空对象。</li><li>让 this 指向这个新的对象。</li><li>执行构造函数里面的代码，给这个新对象添加属性和方法。</li><li>返回这个新对象（所以构造函数里面不需要 return ）。</li></ul><h3 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h3><p>JavaScript 的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的 this 上添加。通过这两种方式添加的成员，就分别称为==静态成员==和==实例成员==。</p><ul><li>静态成员：在构造函数本身上添加的成员称为静态成员，只能由构造函数本身来访问 。</li><li>实例成员：在构造函数内部创建的对象成员称为实例成员，只能由实例化的对象来访问。</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">function Star(name,age)&#123;</span><br><span class="line">    this.name&#x3D;name</span><br><span class="line">    this.age&#x3D;age</span><br><span class="line">    this.sing&#x3D;function()&#123;</span><br><span class="line">        console.log(&#39;SSS&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var XXX&#x3D;new Star(&quot;XX&quot;,&quot;YY&quot;)</span><br><span class="line">&#x2F;&#x2F;1.实例成员就是构造函数内部通过this添加的成员</span><br><span class="line">name age sing 就是实例成员</span><br><span class="line">&#x2F;&#x2F; 实例成员只能通过实例化的对象来访问</span><br><span class="line">console.log(XXX.name);</span><br><span class="line">XXX.sing();</span><br><span class="line">&#x2F;&#x2F; console.log(Star.name);</span><br><span class="line">&#x2F;&#x2F;不可以通过构造函数来访问实例成员</span><br><span class="line">&#x2F;&#x2F; 2. 静态成员 在构造函数本身上添加的成员  sex 就是静态成员</span><br><span class="line">Star.sex &#x3D; &#39;男&#39;;</span><br><span class="line">&#x2F;&#x2F; 静态成员只能通过构造函数来访问</span><br><span class="line">console.log(Star.sex);</span><br><span class="line">console.log(ldh.sex); &#x2F;&#x2F; 不能通过对象来访问</span><br></pre></td></tr></table></figure></div><h3 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h3><p>存在浪费内存的问题</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">function Star(uname, age) &#123;</span><br><span class="line">    this.uname &#x3D; uname;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">    this.sing &#x3D; function() &#123;</span><br><span class="line">        console.log(&#39;我会唱歌&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var ldh &#x3D; new Star(&#39;刘德华&#39;, 18);</span><br><span class="line">var zxy &#x3D; new Star(&#39;张学友&#39;, 19);</span><br></pre></td></tr></table></figure></div><p><img src="https://github.com/BXsweetheart/youdaoNotes/blob/master/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%AE%E9%A2%98.png?raw=true" alt="image"></p><h3 id="构造函数原型-prototype"><a href="#构造函数原型-prototype" class="headerlink" title="构造函数原型 prototype"></a>构造函数原型 prototype</h3><pre><code>构造函数通过原型分配的函数是所有对象所共享的。</code></pre><ol><li><p>JavaScript 规定，每一个构造函数==都有一个 prototype==<br>属性，指向另一个对象。注意这个 prototype 就是一个对<br>象，这个对象的所有属性和方法，都会被构造函数所拥有。</p></li><li><p>我们可以把那些不变的方法，直接定义在 prototype<br>对象上，这样所有对象的实例就可以共享这些方法。</p></li><li><p>一般情况下，我们把公共属性定义到构造函数里面，公共的方法我们放到原型对象身上。</p></li></ol><h4 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h4><ol><li>原型是什么 ？<br>一个对象，我们也称为 prototype 为原型对象。</li><li>原型的作用是什么 ？<br>共享方法。</li></ol><h3 id="对象原型-proto"><a href="#对象原型-proto" class="headerlink" title="对象原型 ** proto **"></a>对象原型 ** proto **</h3><p>对象都会有一个属性 ** proto ** 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 ** proto ** 原型的存在。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        function Star(uname, age) &#123;</span><br><span class="line">            this.uname &#x3D; uname;</span><br><span class="line">            this.age &#x3D; age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Star.prototype.sing &#x3D; function() &#123;</span><br><span class="line">            console.log(&#39;我会唱歌&#39;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var ldh &#x3D; new Star(&#39;刘德华&#39;, 18);</span><br><span class="line">        var zxy &#x3D; new Star(&#39;张学友&#39;, 19);</span><br><span class="line">        ldh.sing();</span><br><span class="line"></span><br><span class="line">        console.log(ldh); &#x2F;&#x2F; 对象身上系统自己添加一个</span><br><span class="line">        __proto__ 指向我们构造函数的原型对象 prototype</span><br><span class="line"></span><br><span class="line">        console.log(ldh.__proto__ &#x3D;&#x3D;&#x3D; Star.prototype);</span><br><span class="line">        &#x2F;&#x2F; 方法的查找规则: 首先先看ldh 对象身上是否有</span><br><span class="line">        sing 方法,如果有就执行这个对象上的sing</span><br><span class="line">        &#x2F;&#x2F; 如果没有sing这个方法,因为有__proto__的存在,就</span><br><span class="line">        去构造函数原型对象prototype身上去查找sing这个方法</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></div><p><img src="https://github.com/BXsweetheart/youdaoNotes/blob/master/proto.png?raw=true" alt="image"></p><ul><li><strong>proto</strong>对象原型和原型对象 prototype 是等价的</li><li><strong>proto</strong>对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype</li></ul><h3 id="constructor-构造函数"><a href="#constructor-构造函数" class="headerlink" title="constructor 构造函数"></a>constructor 构造函数</h3><ol><li><p>对象原型（ ** proto **）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性 ，constructor 我们称为构造函数，因为它指回构造函数本身。</p></li><li><p>constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。</p></li><li><p>一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。</p></li></ol><h3 id="构造函数、实例、原型对象三者之间的关系"><a href="#构造函数、实例、原型对象三者之间的关系" class="headerlink" title="构造函数、实例、原型对象三者之间的关系"></a>构造函数、实例、原型对象三者之间的关系</h3><p><img src="https://github.com/BXsweetheart/youdaoNotes/blob/master/relationship.png?raw=true" alt="image"></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">       function Star(uname, age) &#123;</span><br><span class="line">           this.uname &#x3D; uname;</span><br><span class="line">           this.age &#x3D; age;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 很多情况下,我们需要手动的利用constructor</span><br><span class="line">       这个属性指回原来的构造函数</span><br><span class="line">       &#x2F;&#x2F; Star.prototype.sing &#x3D; function() &#123;</span><br><span class="line">       &#x2F;&#x2F;     console.log(&#39;我会唱歌&#39;);</span><br><span class="line">       &#x2F;&#x2F; &#125;;</span><br><span class="line">       &#x2F;&#x2F; Star.prototype.movie &#x3D; function() &#123;</span><br><span class="line">       &#x2F;&#x2F;     console.log(&#39;我会演电影&#39;);</span><br><span class="line">       &#x2F;&#x2F; &#125;</span><br><span class="line">       Star.prototype &#x3D; &#123;</span><br><span class="line">           &#x2F;&#x2F; 如果我们修改了原来的原型对象,给原型对象赋</span><br><span class="line">           值的是一个对象,则必须手动的利用constructor指</span><br><span class="line">           回原来的构造函数</span><br><span class="line">           constructor: Star,</span><br><span class="line">           sing: function() &#123;</span><br><span class="line">               console.log(&#39;我会唱歌&#39;);</span><br><span class="line">           &#125;,</span><br><span class="line">           movie: function() &#123;</span><br><span class="line">               console.log(&#39;我会演电影&#39;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       var ldh &#x3D; new Star(&#39;刘德华&#39;, 18);</span><br><span class="line">       var zxy &#x3D; new Star(&#39;张学友&#39;, 19);</span><br><span class="line">       console.log(Star.prototype);</span><br><span class="line">       console.log(ldh.__proto__);</span><br><span class="line">       console.log(Star.prototype.constructor);</span><br><span class="line">       console.log(ldh.__proto__.constructor);</span><br><span class="line">   &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></div><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p><img src="https://github.com/BXsweetheart/youdaoNotes/blob/master/%E5%8E%9F%E5%9E%8B%E9%93%BE.png?raw=true" alt="image"></p><ol><li><p>只要是对象就有<strong>proto</strong> 原型, 指向原型对象</p></li><li><p>我们 Star 原型对象里面的<strong>proto</strong>原型指向的是 Object.prototype</p></li><li><p>我们 Object.prototype 原型对象里面的<strong>proto</strong>原型 指向为 null</p></li></ol><h3 id="JavaScript-的成员查找机制-规则"><a href="#JavaScript-的成员查找机制-规则" class="headerlink" title="JavaScript 的成员查找机制(规则)"></a>JavaScript 的成员查找机制(规则)</h3><ul><li>当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。</li><li>如果没有就查找它的原型（也就是 <strong>proto</strong>指向的 prototype 原型对象）。</li><li>如果还没有就查找原型对象的原型（Object 的原型对象）。</li><li>依此类推一直找到 Object 为止（null）。</li><li><strong>proto</strong>对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。</li></ul><h3 id="原型对象-this-指向"><a href="#原型对象-this-指向" class="headerlink" title="原型对象 this 指向"></a>原型对象 this 指向</h3><ul><li>构造函数中的 this 指向我们实例对象。</li><li>原型对象里面放的是方法，这个方法里面的 this 指向的是 这个方法的调用者，也就是这个实例对象。</li></ul><h2 id="扩展内置对象"><a href="#扩展内置对象" class="headerlink" title="扩展内置对象"></a>扩展内置对象</h2><p>可以通过原型对象，对原来的内置对象进行扩展自定义的方法。比如给数组增加自定义求偶数和的功能。（原型对象的应用）</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.sum&#x3D;function()&#123;</span><br><span class="line">        var sum&#x3D;0</span><br><span class="line">        for(i&#x3D;0;i&lt;this.length;i++)&#123;</span><br><span class="line">            sum +&#x3D; this[i]</span><br><span class="line">        &#125;</span><br><span class="line">        return sum</span><br><span class="line">    &#125;</span><br><span class="line">    var arr&#x3D;[1,2,3]</span><br><span class="line">    console.log(arr.sum())</span><br></pre></td></tr></table></figure></div><p><strong>注意</strong><br>数组和字符串==内置对象==不能以对象的形式追加，因为会覆盖原本的内置方法——Array.prototype = {} ，只能使用 Array.prototype.xxx = function(){} 的方式。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>ES6 之前并没有给我们提供 extends 继承。我们可以通过构造函数+原型对象模拟实现继承，被称为组合继承。</p><h3 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h3><p>调用这个函数, 并且修改函数运行时的 this 指向</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">fun.call(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure></div><ul><li>thisArg：当前调用函数 this 的指向对象。</li><li>arg1，arg2：传递的其他参数。</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    function fn(x,y,z)&#123;</span><br><span class="line">        console.log(&quot;deadly sleepy&quot;)</span><br><span class="line">        console.log(this)</span><br><span class="line">        console.log(x+y+z)</span><br><span class="line">    &#125;</span><br><span class="line">    var o&#x3D;&#123;</span><br><span class="line">        think:&quot;want to sleep&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var postgraduate&#x3D;&quot;postgraduate&quot;;</span><br><span class="line">    var is&#x3D;&quot;is&quot;;</span><br><span class="line">    var important&#x3D;&quot;important&quot;</span><br><span class="line">    fn.call()</span><br><span class="line">    fn.call(o)</span><br><span class="line">    fn.call(o,postgraduate,is,important)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></div><h3 id="借用构造函数继承父类型属性"><a href="#借用构造函数继承父类型属性" class="headerlink" title="借用构造函数继承父类型属性"></a>借用构造函数继承父类型属性</h3><p>核心原理：<br>通过 call() 把父类型的 this 指向子类型的 this ，这样就可以实现子类型继承父类型的属性。</p><p>extends 属于类的继承，写法是 class Son extends Father。<br>这里是函数<br>super()是访问和调用父构造函数的方法<br>call()是继承父构造函数的类和方法</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父类</span><br><span class="line">function Father(name, age, sex) &#123;</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">  this.age &#x3D; age;</span><br><span class="line">  this.sex &#x3D; sex;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 子类</span><br><span class="line">function Son(name, age, sex, score) &#123;</span><br><span class="line">  Father.call(this, name, age, sex);  &#x2F;&#x2F; 此时父类的 this</span><br><span class="line">  指向子类的 this，同时调用这个函数</span><br><span class="line">  this.score &#x3D; score;</span><br><span class="line">&#125;</span><br><span class="line">var s1 &#x3D; new Son(&#39;zs&#39;, 18, &#39;男&#39;, 100);</span><br><span class="line">console.dir(s1);</span><br></pre></td></tr></table></figure></div><p>子类构造函数中通过 call 将父类构造函数 this 指向自身，达到继承父类属性目的</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">       &#x2F;&#x2F; 借用父构造函数继承属性</span><br><span class="line">       &#x2F;&#x2F; 1. 父构造函数</span><br><span class="line">       function Father(uname, age) &#123;</span><br><span class="line">           &#x2F;&#x2F; this 指向父构造函数的对象实例</span><br><span class="line">           this.uname &#x3D; uname;</span><br><span class="line">           this.age &#x3D; age;</span><br><span class="line">       &#125;</span><br><span class="line">       Father.prototype.money &#x3D; function() &#123;</span><br><span class="line">           console.log(100000);</span><br><span class="line"></span><br><span class="line">       &#125;;</span><br><span class="line">       &#x2F;&#x2F; 2 .子构造函数</span><br><span class="line">       function Son(uname, age, score) &#123;</span><br><span class="line">           &#x2F;&#x2F; this 指向子构造函数的对象实例</span><br><span class="line">           Father.call(this, uname, age);</span><br><span class="line">           this.score &#x3D; score;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; Son.prototype &#x3D; Father.prototype;</span><br><span class="line">      &#x2F;&#x2F;这样直接赋值会有问题,如果修改了子原型对象,父原型</span><br><span class="line">      &#x2F;&#x2F;对象也会跟着一起变化</span><br><span class="line">       Son.prototype &#x3D; new Father();</span><br><span class="line">       &#x2F;&#x2F; 如果利用对象的形式修改了原型对象,别忘了利用</span><br><span class="line">       &#x2F;&#x2F;constructor 指回原来的构造函数</span><br><span class="line">       Son.prototype.constructor &#x3D; Son;</span><br><span class="line">       &#x2F;&#x2F; 这个是子构造函数专门的方法,原型链查找</span><br><span class="line">       Son.prototype.exam &#x3D; function() &#123;</span><br><span class="line">           console.log(&#39;孩子要考试&#39;);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       var son &#x3D; new Son(&#39;刘德华&#39;, 18, 100);</span><br><span class="line">       console.log(son);</span><br><span class="line">       console.log(Father.prototype);</span><br><span class="line">       console.log(Son.prototype.constructor);</span><br><span class="line">   &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></div><p>一般情况下，对象的方法都在构造函数的原型对象中设置，通过构造函数无法继承父类方法。<br>核心原理：</p><ul><li>将子类所共享的方法提取出来，让子类的 prototype 原型对象 = new 父类()</li><li>本质：子类原型对象等于是实例化父类，因为父类实例化之后另外开辟空间，就不会影响原来父类原型对象</li><li>将子类的 constructor 从新指向子类的构造函数</li></ul><h3 id="类的本质"><a href="#类的本质" class="headerlink" title="类的本质"></a>类的本质</h3><ol><li>class 本质还是 function（简单认为，构造函数的另外一种写法）；</li><li>类的所有方法都定义在类的 prototype 属性上；</li><li>类创建的实例,里面也有<strong>proto</strong>指向类的 prototype 原型对象；</li><li>所以 ES6 的类它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已；</li><li>所以 ES6 的类其实就是语法糖；</li><li>语法糖:语法糖就是一种便捷写法。简单理解,有两种方法可以实现同样的功能,但是一种写法更加清晰、方便,那么这个方法就是语法糖。</li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/posts/54b11a0c.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 02 2020 23:48:26 GMT+0800 (GMT+08:00) --><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><blockquote><p>Promise出现的本质是为了解决异步函数回调地狱的问题</p></blockquote><h2 id="1-回调地狱"><a href="#1-回调地狱" class="headerlink" title="1.回调地狱"></a>1.回调地狱</h2><p>曾几何时，我们的代码是这样的，为了拿到回调的结果，不得不<code>callback hell</code>，这种环环相扣的代码可以说是相当恶心了</p><a id="more"></a><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line">fs.readFile(<span class="string">'./a.txt'</span>,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">  fs.readFile(data,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">    fs.readFile(data,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><p>终于，我们的<code>盖世英雄</code>出现了，他身披金甲圣衣、驾着七彩祥云。好吧打岔儿了，没错他就是我们的<code>Promise</code>，那让我们来看看用了<code>Promise</code>之后，上面的代码会变成什么样吧</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    fs.readFile(url,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">error,data</span>)</span>&#123;</span><br><span class="line">      error &amp;&amp; reject(error)</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read(<span class="string">'./a.txt'</span>).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> read(data) </span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> read(data)  </span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><p>如上所示</p><hr><h2 id="2-重点开始，小眼睛都看过来"><a href="#2-重点开始，小眼睛都看过来" class="headerlink" title="2.重点开始，小眼睛都看过来"></a>2.重点开始，小眼睛都看过来</h2><h3 id="2-1constructor"><a href="#2-1constructor" class="headerlink" title="2.1constructor"></a>2.1constructor</h3><p>我们先声明一个类，叫做<code>Promise</code>，里面是构造函数。如果es6还有问题的可以去阮大大的博客上学习一下（传送门☞<a href="http://es6.ruanyifeng.com" target="_blank" rel="noopener">es6</a>）</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor)&#123;</span><br><span class="line">    <span class="comment">//控制状态，使用了一次之后，接下来的都不被使用</span></span><br><span class="line">    <span class="keyword">this</span>.status = <span class="string">'pendding'</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.reason = <span class="literal">undefined</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义resolve函数</span></span><br><span class="line">    <span class="keyword">let</span> resolve = <span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="comment">//这里pendding，主要是为了防止executor中调用了两次resovle或reject方法，而我们只调用一次</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.status===<span class="string">'pendding'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'resolve'</span></span><br><span class="line">        <span class="keyword">this</span>.value = data</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义reject函数</span></span><br><span class="line">    <span class="keyword">let</span> reject = <span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.status===<span class="string">'pendding'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'reject'</span>        </span><br><span class="line">        <span class="keyword">this</span>.reason = data</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//executor方法可能会抛出异常，需要捕获</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="comment">//将resolve和reject函数给使用者      </span></span><br><span class="line">      executor(resolve,reject)      </span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">      <span class="comment">//如果在函数中抛出异常则将它注入reject中</span></span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>那么接下来我会分析一下上面代码的作用，原理：</p></blockquote><ul><li><p><code>executor</code>：这是实例<code>Promise</code>对象时在构造器中传入的参数，一般是一个<code>function(resolve,reject){}</code></p></li><li><p><code>status：Promise</code>的状态，一开始是默认的pendding状态，每当调用道resolve和reject方法时，就会改变其值，在后面的then方法中会用到</p></li><li><p><code>value：resolve</code>回调成功后，调用resolve方法里面的参数值</p></li><li><p><code>reason：reject</code>回调成功后，调用reject方法里面的参数值</p></li><li><p><code>resolve：</code>声明resolve方法在构造器内，通过传入的executor方法传入其中，用以给使用者回调</p></li><li><p><code>reject：</code>声明reject方法在构造器内，通过传入的executor方法传入其中，用以给使用者回调</p></li></ul><h3 id="2-2-then"><a href="#2-2-then" class="headerlink" title="2.2 then"></a>2.2 then</h3><p><code>then</code>方法是<code>Promise</code>中最为重要的方法，他的用法大家都应该已经知道，就是将<code>Promise</code>中的<code>resolve</code>或者<code>reject</code>的结果拿到，那么我们就能知道这里的<code>then</code>方法需要两个参数，成功回调和失败回调，上代码！</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">then(onFufilled,onRejected)&#123;  </span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'resolve'</span>)&#123;</span><br><span class="line">    onFufilled(<span class="keyword">this</span>.value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'reject'</span>)&#123;</span><br><span class="line">    onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这里主要做了将构造器中resolve和reject的结果传入<code>onFufilled</code>和<code>onRejected</code>中，注意这两个是使用者传入的参数，是个方法。所以你以为这么简单就完了？要想更Swag的应对各种场景，我们必须得再完善。继续往下走！</p><h2 id="3-异步的Promise"><a href="#3-异步的Promise" class="headerlink" title="3.异步的Promise"></a>3.异步的Promise</h2><p>之前我们只是处理了同步情况下的Promise，简而言之所有操作都没有异步的成分在内。那么如果是异步该怎么办？</p><h3 id="3-1-callback"><a href="#3-1-callback" class="headerlink" title="3.1 callback"></a>3.1 callback</h3><blockquote><p>最早处理异步的方法就是callback，就相当于我让你帮我扫地，我会在给你发起任务时给你一个手机，之后我做自己的事情去，不用等你，等你扫完地就会打手机给我，诶，我就知道了地扫完了。这个手机就是callback，回调函数。</p></blockquote><p>首先我们需要改一下构造器里的代码，分别添加两个回调函数的数组，分别对应成功回调和失败回调。他们的作用是当成功执行resolve或reject时，执行callback。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存放成功回调的函数</span></span><br><span class="line"><span class="keyword">this</span>.onResolvedCallbacks = []</span><br><span class="line"><span class="comment">//存放失败回调的函数</span></span><br><span class="line"><span class="keyword">this</span>.onRejectedCallbacks = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> resolve = <span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.status===<span class="string">'pendding'</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>.status = <span class="string">'resolve'</span></span><br><span class="line">    <span class="keyword">this</span>.value = data</span><br><span class="line">    <span class="comment">//监听回调函数</span></span><br><span class="line">    <span class="keyword">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span>=&gt;</span>fn())</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> reject = <span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.status===<span class="string">'pendding'</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>.status = <span class="string">'reject'</span>        </span><br><span class="line">    <span class="keyword">this</span>.reason = data</span><br><span class="line">    <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span>=&gt;</span>fn())</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>然后是then需要多加一个状态判断，当Promise中是异步操作时，需要在我们之前定义的回调函数数组中添加一个回调函数。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'pendding'</span>)&#123;</span><br><span class="line">  <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// to do....</span></span><br><span class="line">    <span class="keyword">let</span> x = onFufilled(<span class="keyword">this</span>.value)</span><br><span class="line">    resolvePromise(promise2,x,resolve,reject)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">    resolvePromise(promise2,x,resolve,reject)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>ok！大功告成，异步已经解决了</p><h3 id="3-2-Promise-resolve"><a href="#3-2-Promise-resolve" class="headerlink" title="3.2 Promise.resolve"></a>3.2 Promise.resolve</h3><blockquote><p>一般情况下我们都会使用new Promise（）来创建Promise对象，但是除此之外我们也可以使用其他方法。</p></blockquote><p>静态方法<code>Promise.resolve(value)</code>可以认为是<code>new Promise()</code>方法的快捷方式。</p><p>比如Promise.resolve(20)可以认为是以下代码的语法糖。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">				resolve(<span class="number">20</span>)</span><br><span class="line">			&#125;)</span><br></pre></td></tr></table></figure></div><h2 id="4-完善Promise"><a href="#4-完善Promise" class="headerlink" title="4.完善Promise"></a>4.完善Promise</h2><blockquote><p>我们现在已经基本完成了<code>Promise</code>的<code>then</code>方法，那么现在我们需要看看他的其他方法。</p></blockquote><h3 id="4-1-catch"><a href="#4-1-catch" class="headerlink" title="4.1 catch"></a>4.1 catch</h3><p>相信大家都知道catch这个方法是用来捕获Promise中的reject的值，也就是相当于then方法中的onRejected回调函数，那么问题就解决了。我们来看代码。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//catch方法</span></span><br><span class="line"><span class="keyword">catch</span>(onRejected)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>,onRejected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>该方法是挂在Promise原型上的方法。当我们调用catch传callback的时候，就相当于是调用了then方法。</p></blockquote><h3 id="4-2-resolve-reject"><a href="#4-2-resolve-reject" class="headerlink" title="4.2 resolve/reject"></a>4.2 resolve/reject</h3><p>大家一定都看到过<code>Promise.resolve()</code>、<code>Promise.reject()</code>这两种用法，它们的作用其实就是返回一个Promise对象，我们来实现一下。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//resolve方法</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(val)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//reject方法</span></span><br><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    reject(val)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>这两个方法是直接可以通过class调用的，原理就是返回一个内部是resolve或reject的Promise对象。</p></blockquote><h3 id="4-3-all"><a href="#4-3-all" class="headerlink" title="4.3 all"></a>4.3 all</h3><p>Promise.all 生成并返回一个新的Promise对象，所以它可以使用Promise实例的所有方法。参数传递promise数组中所有的Promise对象都变为resolve的时候，该方法才会返回，新创建的Promise则会使用这些promise的值。</p><p>如果参数中的任何一个Promise为reject的话，则整个Promise.all调用会立即终止，并返回一个reject的新的Promise对象。</p><p>由于参数数组中的每个元素都是由Promise.resolve包装（wrap）的，所以Promose.all可以处理不同类型的Promose对象。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//all方法(获取所有的promise，都执行then，把结果放到数组，一起返回)</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)<span class="comment">// [1,2,3]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><blockquote><p>其原理就是将参数中的数组取出遍历，每当执行成功都会执行processData方法，processData方法就是用来记录每个Promise的值和它对应的下标，当执行的次数等于数组长度时就会执行resolve，把arr的值给then。这里会有一个坑，如果你是通过arr数组的长度来判断他是否应该resolve的话就会出错，为什么呢？因为js数组的特性，导致如果先出来的是1位置上的值进arr，那么0位置上也会多一个空的值，所以不合理。</p></blockquote><h3 id="4-4-race"><a href="#4-4-race" class="headerlink" title="4.4 race"></a>4.4 race</h3><p>Promise.race 生成并返回一个新的Promise对象。<br>参数Promise数组中的任何一个Promise 对象如果变为resolve 或者reject的话，该函数就会返回，并使用这个Promise 对象的值进行resolve 或者reject。</p><p>注：Promise.race方法只会执行第一个返回的Promise对象</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//race方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(<span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">5000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(<span class="number">2</span>)</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.race([p1(), p2()]).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)<span class="comment">// 三秒钟后打印2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><h2 id="Promise语法糖-deferred"><a href="#Promise语法糖-deferred" class="headerlink" title="Promise语法糖 deferred"></a>Promise语法糖 deferred</h2><p>语法糖这三个字大家一定很熟悉，作为一个很Swag的前端工程师，对<code>async/await</code>这对兄弟肯定很熟悉，没错他们就是<code>generator</code>的语法糖。而我们这里要讲的语法糖是Promise的。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//promise语法糖 也用来测试</span></span><br><span class="line"><span class="built_in">Promise</span>.deferred = <span class="built_in">Promise</span>.defer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dfd = &#123;&#125;</span><br><span class="line">  dfd.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    dfd.resolve = resolve</span><br><span class="line">    dfd.reject = reject</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> dfd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>什么作用呢？看下面代码你就知道了</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="built_in">Promise</span> = <span class="built_in">require</span>(<span class="string">'./promises'</span>)</span><br><span class="line"><span class="comment">//Promise上的语法糖，为了防止嵌套，方便调用</span></span><br><span class="line"><span class="comment">//坏处 错误处理不方便</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> defer = <span class="built_in">Promise</span>.defer()</span><br><span class="line">  fs.readFile(<span class="string">'./1.txt'</span>,<span class="string">'utf8'</span>,(err,data)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)defer.reject(err)</span><br><span class="line">    defer.resolve(data)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> defer.Promise</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>没错，我们可以方便的去调用他语法糖defer中的Promise对象。那么它还有没有另外的方法呢？答案是有的。我们需要在全局上安装promises-aplus-tests插件npm i promises-aplus-tests -g，再输入promises-aplus-tests [js文件名] 即可验证你的Promise的规范。</p></blockquote><p>文章非本人原创，由于原文很多代码比较复杂，本人做了一些简化，看起来容易理解一些，不过没有原文那么详细，知识不问出处，请珍惜他人劳动成果<br>原文地址<a href="https://juejin.im/post/5b32f552f265da59991155f0" target="_blank" rel="noopener">掘金大咖</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title>JS运行机制</title>
    <url>/posts/6fdc6fb4.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 02 2020 23:48:26 GMT+0800 (GMT+08:00) --><h2 id="一、引子"><a href="#一、引子" class="headerlink" title="一、引子"></a>一、引子</h2><p>本文介绍JavaScript运行机制，这一部分比较抽象，我们先从一道面试题入手：</p><a id="more"></a><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 请问数字打印顺序是什么？</span></span><br></pre></td></tr></table></figure></div><p>这一题看似很简单，但如果你不了解JavaScript运行机制，很容易就答错了。题目的答案是依次输出1 2 3，如果你有疑惑，下文有详细解释。</p><h2 id="二、理解JS的单线程的概念"><a href="#二、理解JS的单线程的概念" class="headerlink" title="二、理解JS的单线程的概念"></a>二、理解JS的单线程的概念</h2><p>JavaScript语言的一大特点就是单线程，也就是说，<strong>同一个时间只能做一件事</strong>。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。</p><p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p><h2 id="三、理解任务队列-消息队列"><a href="#三、理解任务队列-消息队列" class="headerlink" title="三、理解任务队列(消息队列)"></a>三、理解任务队列(消息队列)</h2><p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。JavaScript语言的设计者意识到这个问题，将所有任务分成两种，<span style="color:#f40">一种是同步任务（synchronous），另一种是异步任务（asynchronous）</span>。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。<span style="color:#f40">异步任务包括宏任务和微任务(后面会重点介绍)</span>，接下来我们通过两个例子说明同步任务和异步任务的区别：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"A"</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123; &#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"B"</span>);</span><br><span class="line"><span class="comment">// 请问最后的输出结果是什么？</span></span><br></pre></td></tr></table></figure></div><p>如果你的回答是A,恭喜你答对了，因为这是同步任务，程序由上到下执行，遇到while()死循环，下面语句就没办法执行。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"A"</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"B"</span>);</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;&#125;</span><br><span class="line"><span class="comment">// 请问最后的输出结果是什么？</span></span><br></pre></td></tr></table></figure></div><p>如果你的答案是A，恭喜你现在对js运行机制已经有个粗浅的认识了！题目中的setTimeout()就是个异步任务。<strong>在所有同步任务执行完之前，任何的异步任务是不会执行的</strong>，关于这点下文还会详细说明。</p><h2 id="四、理解Event-Loop"><a href="#四、理解Event-Loop" class="headerlink" title="四、理解Event Loop"></a>四、理解Event Loop</h2><p><strong>异步执行的运行机制如下：</strong></p><ol><li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</li><li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li><li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li><li>主线程不断重复上面的第三步。</li></ol><p><strong>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。</strong>这个过程会循环反复。以下这张图可以很好说明这点。<br><img src="/posts/6fdc6fb4/event-loop.png" alt="Event Loop"></p><h2 id="五、哪些语句会放入异步任务队列及放入时机"><a href="#五、哪些语句会放入异步任务队列及放入时机" class="headerlink" title="五、哪些语句会放入异步任务队列及放入时机"></a>五、哪些语句会放入异步任务队列及放入时机</h2><p><strong>一般来说，有以下四种会放入异步任务队列：</strong></p><ol><li>setTimeout和setlnterval</li><li>DOM事件</li><li>ES6中的Promise</li><li>Ajax异步请求</li></ol><p><strong>javascript 代码运行分两个阶段：</strong></p><ol><li>预解析—把所有的函数定义提前，所有的变量声明提前，变量的赋值不提前</li><li>执行—从上到下执行（按照js运行机制）</li></ol><p>至于放入异步任务队列的时机，我们通过 setTimeout的例子和Ajax例子来详细说明：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例题1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line"> <span class="built_in">console</span>.log(i);  </span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 请问最后的输出结果是什么？</span></span><br></pre></td></tr></table></figure></div><p>for循环一次碰到一个 setTimeout()，<span style="color:#f40">并不是马上把setTimeout()拿到异步队列中，而要等到一秒后，才将其放到任务队列里面</span>，一旦”执行栈”中的所有同步任务执行完毕（即for循环结束，此时i已经为5），系统就会读取已经存放”任务队列”的setTimeout()（有五个），于是答案是输出5个5。</p><p>上面也提到，<span style="color:#EFEFDA"><strong>在到达指定时间时，定时器就会将相应回调函数插入“任务队列”尾部。这就是“定时器（timer）”功能。</strong></span></p><ul><li>关于定时器的重要补充：<br>定时器包括setTimeout与 setInterval 两个方法。它们的第二个参数是指定其回调函数推迟/每隔多少毫秒数后执行。</li></ul><p>对于第二个参数有以下需要注意的地方：</p><p>当第二个参数缺省时，默认为 0；</p><p>当指定的值小于 4 毫秒，则增加到 4ms(4ms 是 HTML5 标准指定的，对于 2010 年及之前的浏览器则是 10ms);也就是说至少需要4毫秒，该setTimeout()拿到任务队列中。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例题2</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">url：“xxxxx<span class="string">",</span></span><br><span class="line"><span class="string">success:function (result)&#123;</span></span><br><span class="line"><span class="string">console.log("</span>a<span class="string">")</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">setTimeout(function ()&#123;</span></span><br><span class="line"><span class="string">console.log("</span>b<span class="string">")</span></span><br><span class="line"><span class="string">&#125;,100)</span></span><br><span class="line"><span class="string">setTimeout(function ()&#123;</span></span><br><span class="line"><span class="string">console.log("</span>c<span class="string">")</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">console.log("</span>d<span class="string">");</span></span><br></pre></td></tr></table></figure></div><p><img src="/posts/6fdc6fb4/ajax.png" alt></p><p>ajax加载完成时才会放入异步队列，至于这段时间不确定，所有有两种情况：①大于100ms,最后的结果是 d c b a ;②小于100ms,最后的结果便是d c a b。</p><h2 id="六、微任务-Microtask-与宏任务-Macrotask"><a href="#六、微任务-Microtask-与宏任务-Macrotask" class="headerlink" title="六、微任务(Microtask)与宏任务(Macrotask)"></a>六、微任务(Microtask)与宏任务(Macrotask)</h2><p>我们上面提到异步任务分为宏任务和微任务，宏任务队列可以有多个，微任务队列只有一个。</p><ul><li>宏任务包括：script(全局任务), setTimeout, setInterval, setImmediate, I/O, UI rendering。</li><li>微任务包括: new Promise().then(回调), process.nextTick, Object.observe(已废弃), MutationObserver(html5新特性)</li></ul><p><strong>当执行栈中的所有同步任务执行完毕时，是先执行宏任务还是微任务呢？</strong></p><ul><li>由于执行代码入口都是全局任务 script，而全局任务属于宏任务，所以当栈为空，同步任务任务执行完毕时，会先执行微任务队列里的任务。</li><li>微任务队列里的任务全部执行完毕后，会读取宏任务队列中拍最前的任务。</li><li>执行宏任务的过程中，遇到微任务，依次加入微任务队列。</li><li>栈空后，再次读取微任务队列里的任务，依次类推。</li></ul><p><img src="/posts/6fdc6fb4/no-referrer.png" alt="no-referrer"></p><p>一句话概括上面的流程图：<span style="color:#f40">当某个宏任务队列的中的任务全部执行完以后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，就查看是否有其他宏任务队列。</span></p><p>接下来我们看两道例子来介绍上面流程：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>)  </span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>)</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise2'</span>)    </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br></pre></td></tr></table></figure></div><p>最后输出结果是Promise1，setTimeout1，Promise2，setTimeout2</p><ul><li>一开始执行栈的同步任务执行完毕，会去查看是否有微任务队列，上题中存在(有且只有一个)，然后执行微任务队列中的所有任务输出Promise1，同时会生成一个宏任务 setTimeout2</li><li>然后去查看宏任务队列，宏任务 setTimeout1 在 setTimeout2 之前，先执行宏任务 setTimeout1，输出 setTimeout1</li><li>在执行宏任务setTimeout1时会生成微任务Promise2 ，放入微任务队列中，接着先去清空微任务队列中的所有任务，输出 Promise2</li><li>清空完微任务队列中的所有任务后，就又会去宏任务队列取一个，这回执行的是 setTimeout2</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'----------------- start -----------------'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">  resolve();  <span class="comment">// 修改promise实例对象的状态为成功的状态</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise实例成功回调执行'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'----------------- end -----------------'</span>);</span><br></pre></td></tr></table></figure></div><p><img src="/posts/6fdc6fb4/start-end.png" alt></p><h2 id="七、解析"><a href="#七、解析" class="headerlink" title="七、解析"></a>七、解析</h2><p>如果要输出0~4，上面例题应该如何修改？</p><ol><li><p>将var变为let</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li><p>加个立即执行函数</p></li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="3"><li>也可以通过这样加闭包</li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i &lt; <span class="number">5</span>;i++)&#123;  </span><br><span class="line">  <span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">      <span class="keyword">var</span> j = i;    </span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">          <span class="built_in">console</span>.log(j);  </span><br><span class="line">      &#125;,<span class="number">1000</span>)  </span><br><span class="line">  &#125;    </span><br><span class="line">a();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>原型和原型链</title>
    <url>/posts/139b1e40.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 02 2020 23:48:26 GMT+0800 (GMT+08:00) --><h2 id="原型对象prototype"><a href="#原型对象prototype" class="headerlink" title="原型对象prototype"></a>原型对象prototype</h2><ul><li>每一个函数对象都有一个prototype属性，但是普通对象是没有的</li><li>普通对象都是通过函数创建的<a id="more"></a><blockquote><p>在 ECMAScript 核心所定义的全部属性中，最耐人寻味的就要数 prototype 属性了。对于 ECMAScript 中的引用类型而言，prototype 是保存着它们所有实例方法的真正所在。换句话所说，诸如 toString()和 valuseOf()等方法实际上都保存在 prototype 名下，只不过是通过各自对象的实例访问罢了。—-《JavaScript 高级程序设计》</p></blockquote></li></ul><p>JS所有对象分为函数对象和普通对象。凡是通过new Function()创建得来的对象都是函数对象。函数对象拥有prototype属性和proto属性。</p><p><strong>prototype</strong></p><blockquote><p>JS设计之初为了实现简单继承，引入了prototype属性，也叫原型对象（显式原型）。</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原型对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Animal.prototype) <span class="comment">//Object  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype) <span class="comment">// Object</span></span><br></pre></td></tr></table></figure></div><p>可以看出，从本质上讲，prototype是一个普通对象，是函数对象的构造函数创建的一个实例。相当于在Animal创建的时候，自动创建了一个它的实例，并且把这个实例赋值给了prototype。</p><p>但是存在一个特例Function， Function.prototype是原型对象，本质却是函数对象。作为一个函数对象，又没有prototype属性</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype) <span class="comment">// 特殊 Function  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype.prototype) <span class="comment">//undefined 函数对象却没有prototype属性</span></span><br></pre></td></tr></table></figure></div><p><strong>proto属性</strong><br>所有的对象obj(null和undefined除外)都具有proto属性（隐式原型），proto属性在本质上为一个指针，指向创造obj对象的函数对象的prototype属性。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age= age;</span><br><span class="line">        &#125;</span><br><span class="line">        Animal.prototype = &#123;</span><br><span class="line">            alertName()&#123;</span><br><span class="line">                alert(<span class="keyword">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建实例</span></span><br><span class="line">        <span class="keyword">var</span> dog = <span class="keyword">new</span> Animal(<span class="string">"大黄"</span>);</span><br><span class="line">        dog .print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             alert(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">        dog.print();  <span class="comment">//大黄</span></span><br><span class="line">        dog.alertName();  <span class="comment">//大黄</span></span><br></pre></td></tr></table></figure></div><p>print()方法是dog实例本身具有的方法，所以dog.print()输出“大黄”；alertName()不属于dog实例的方法，属于构造函数的方法，dog.alertName()也会输出“大黄”，是因为dog实例继承了构造函数的方法。</p><p>实例dog的隐式原型指向它构造函数的显式原型，指向的意思是恒等于，即</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">dog.__proto__ === Animal.prototype<span class="comment">// true</span></span><br></pre></td></tr></table></figure></div><h2 id="构造器constructor"><a href="#构造器constructor" class="headerlink" title="构造器constructor"></a>构造器constructor</h2><p>构造器constructor就是用来构造函数对象的，constructor 属性返回对创建此对象的函数对象的引用。通俗了讲就是指向当前对象的爸爸</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a.constructor===<span class="built_in">Function</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(a.prototype.constructor===a); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></div><p>函数a是由Function创造出来,那么它的constructor指向的Function,a.prototype是由new a()方式创造出来,那么a.prototype.constructor理应指向a。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>原型链是JS中实现继承的主要方法。其基本思想就是让一个引用类型继承另一个引用类型的属性和方法。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.animalType = <span class="string">"animal"</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">Animal.prototype.getAnimalType = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.animalType ;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.Dogtype = <span class="string">"dog"</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal();  </span><br><span class="line"></span><br><span class="line">Dog.prototype.getDogType = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.Dogtype ;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dahuang = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line">alert(dahuang.getAnimalType ());<span class="comment">// animal</span></span><br></pre></td></tr></table></figure></div><p>dahuang.getAnimalType ()打印结果为animal，dahuang自身没有getAnimalType ()方法，那么就会去它的proto(即它的构造函数的prototype)中寻找，发现Dog中也没有，于是顺着proto再往上找，在<code>Animal.prototype.getAnimalType</code>找到，返回结果 。</p><p><code>如果Animal中还是没有，就接着往上找，一直到Object.prototype原型对象终止</code></p><ul><li>总结得出<strong>原型链</strong>就是：<br>如果在对象上没有找到需要的属性或者方法引用，引擎就会在[[prototype]]关联的对象上进行查找。同理，如果在后者中也没有找到需要的引用就会继续查找它[[prototype]，以此类推。一直到<code>Object.prototype</code>原型对象终止，这就是原型链。<code>Object.prototype</code>是原型链的顶端。</li></ul><p><code>如果找到Object.prototype上还找不到，原路返回，告诉实例此方法或属性没有找到或者没有定义。如果说在中间的任意一个环节找到了，就停止向上查找直接返回结果</code></p><h2 id="原型对象和原型链的作用"><a href="#原型对象和原型链的作用" class="headerlink" title="原型对象和原型链的作用"></a>原型对象和原型链的作用</h2><p>如果构造函数中有很多属性和方法，那么构造函数所有的实例化对象都是公用这些属性和方法的，当有多个实例想用共用这些东西的时候，每个实例都拷贝一份，就造成极大的资源浪费，那是不是可以考虑存把这些需要共用的属性和方法放到一个共同的东西上。这个共同的东西就是原型对象（prototype）。</p><p><code>当然原型链实现继承也会存在一些问题，最主要的问题来自包含引用类型的原型。其次就是在创建子类型的实例时，不能向超类型的构造函数中传递参数。</code></p><h2 id="构造函数、实例对象、原型对象三者之间的关系"><a href="#构造函数、实例对象、原型对象三者之间的关系" class="headerlink" title="构造函数、实例对象、原型对象三者之间的关系"></a>构造函数、实例对象、原型对象三者之间的关系</h2><p><img src="/posts/139b1e40/yuanxing.webp" alt="构造函数、实例对象、原型三者的关系"></p><p>任何函数都具有一个 prototype 属性，该属性是一个对象。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(F.prototype) <span class="comment">// =&gt; object</span></span><br><span class="line"></span><br><span class="line">F.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hi!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>构造函数的 <code>prototype</code> 对象默认都有一个 <code>constructor</code> 属性，指向 <code>prototype</code> 对象所在函数。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(F.constructor === F) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure></div><p>通过构造函数得到的实例对象内部会包含一个指向构造函数的 <code>prototype</code> 对象的指针 <code>__proto__</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> F()</span><br><span class="line"><span class="built_in">console</span>.log(instance.__proto__ === F.prototype) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure></div><p><code>__proto__</code> 是非标准属性。</p><p>实例对象可以直接访问原型对象成员。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">instance.sayHi() <span class="comment">// =&gt; hi!</span></span><br></pre></td></tr></table></figure></div><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul><li>任何函数都具有一个 <code>prototype</code> 属性，该属性是一个对象</li><li>构造函数的 <code>prototype</code> 对象默认都有一个 <code>constructor</code> 属性，指向 <code>prototype</code> 对象所在函数</li><li>通过构造函数得到的实例对象内部会包含一个指向构造函数的 <code>prototype</code> 对象的指针 <code>__proto__</code></li><li>所有实例都直接或间接继承了原型对象的成员</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的Event Loop</title>
    <url>/posts/889ebc65.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 02 2020 23:48:26 GMT+0800 (GMT+08:00) --><h2 id="Event-Loop是什么"><a href="#Event-Loop是什么" class="headerlink" title="Event Loop是什么"></a>Event Loop是什么</h2><p><strong>event loop是一个执行模型，在不同的地方有不同的实现。浏览器和NodeJS基于不同的技术实现了各自的Event Loop。</strong></p><ul><li><p>浏览器的Event Loop是在html5的规范中明确定义。</p></li><li><p>NodeJS的Event Loop是基于libuv实现的。可以参考Node的官方文档以及libuv的官方文档。</p></li><li><p>libuv已经对Event Loop做出了实现，而HTML5规范中只是定义了浏览器中Event Loop的模型，具体的实现留给了浏览器厂商。</p></li></ul><h2 id="宏队列和微队列"><a href="#宏队列和微队列" class="headerlink" title="宏队列和微队列"></a>宏队列和微队列</h2><p>宏队列，<code>macrotask</code>，也叫<code>tasks</code>。 一些异步任务的回调会依次进入macro task queue，等待后续被调用，这些异步任务包括：</p><ul><li>setTimeout</li><li>setInterval</li><li>setImmediate (Node独有)</li><li>requestAnimationFrame (浏览器独有)</li><li>I/O</li><li>UI rendering (浏览器独有)</li></ul><p>（注：这里只针对浏览器和NodeJS）</p><h2 id="浏览器的Event-Loop"><a href="#浏览器的Event-Loop" class="headerlink" title="浏览器的Event Loop"></a>浏览器的Event Loop</h2><p>我们先来看一张图，再看完这篇文章后，请返回来再仔细看一下这张图，相信你会有更深的理解。</p><p><img src="http://blog.yptup.top/imageEvent-Loop.png" alt="Event-Loop.png"></p><p>这张图将浏览器的Event Loop完整的描述了出来，我来讲执行一个JavaScript代码的具体流程：</p><ol><li>执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）；</li><li>全局Script代码执行完毕后，调用栈Stack会清空；</li><li>从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；</li><li>继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。<strong>注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行；</strong></li><li>microtask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；</li><li>取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；</li><li>执行完毕后，调用栈Stack为空；</li><li>重复第3-7个步骤；</li><li>重复第3-7个步骤；</li><li>……</li></ol><p><strong>可以看到，这就是浏览器的事件循环Event Loop</strong></p><p>这里归纳3个重点：</p><ol><li>宏队列macrotask一次只从队列中取一个任务执行，执行完后就去执行微任务队列中的任务；</li><li>微任务队列中所有的任务都会被依次取出来执行，知道microtask queue为空；</li><li>图中没有画UI rendering的节点，因为这个是由浏览器自行判断决定的，但是只要执行UI rendering，它的节点是在执行完所有的microtask之后，下一个macrotask之前，紧跟着执行UI render。</li></ol><p>好了，概念性的东西就这么多，来看几个示例代码，测试一下你是否掌握了:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">  resolve(<span class="number">5</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">7</span>);</span><br></pre></td></tr></table></figure></div><p>这里结果会是什么呢？运用上面了解到的知识，先自己做一下试试看。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确答案</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure></div><p>我们来分析一下整个流程：</p><blockquote><p><strong>执行全局Script代码</strong></p></blockquote><p><strong>Step 1</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></div><p>Stack Queue: [console]<br>Macrotask Queue: []<br>Microtask Queue: []</p><blockquote><p>打印结果：<br>1</p></blockquote><p><strong>Step 2</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这个回调函数叫做callback1，setTimeout属于macrotask，所以放到macrotask queue中</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><p>Stack Queue: [setTimeout]</p><p>Macrotask Queue: [callback1]</p><p>Microtask Queue: []</p><blockquote><p>打印结果：<br>1</p></blockquote><p><strong>Step 3</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 注意，这里是同步执行的</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">  resolve(<span class="number">5</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这个回调函数叫做callback2，promise属于microtask，所以放到microtask queue中</span></span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><p>Stack Queue: [promise]</p><p>Macrotask Queue: [callback1]</p><p>Microtask Queue: [callback2]</p><blockquote><p>打印结果：<br>1<br>4</p></blockquote><p><strong>Step 5</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这个回调函数叫做callback3，setTimeout属于macrotask，所以放到macrotask queue中</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><p>Stack Queue: [setTimeout]</p><p>Macrotask Queue: [callback1, callback3]</p><p>Microtask Queue: [callback2]</p><blockquote><p>打印结果：<br>1<br>4</p></blockquote><p><strong>Step 6</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">7</span>)</span><br></pre></td></tr></table></figure></div><p>Stack Queue: [console]</p><p>Macrotask Queue: [callback1, callback3]</p><p>Microtask Queue: [callback2]</p><blockquote><p>打印结果：<br>1<br>4<br>7</p></blockquote><ul><li>好啦，全局Script代码执行完了，进入下一个步骤，从microtask queue中依次取出任务执行，直到microtask queue队列为空。</li></ul><p><strong>Step 7</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(data) <span class="comment">// 这里data是Promise的决议值5</span></span><br></pre></td></tr></table></figure></div><p>Stack Queue: [callback2]</p><p>Macrotask Queue: [callback1, callback3]</p><p>Microtask Queue: []</p><blockquote><p>打印结果：<br>1<br>4<br>7<br>5</p></blockquote><ul><li>这里microtask queue中只有一个任务，执行完后开始从宏任务队列macrotask queue中取位于队首的任务执行</li></ul><p><strong>Step 8</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></div><p>Stack Queue: [callback1]</p><p>Macrotask Queue: [callback3]</p><p>Microtask Queue: []</p><blockquote><p>打印结果：<br>1<br>4<br>7<br>5<br>2</p></blockquote><p>但是，执行callback1的时候又遇到了另一个Promise，Promise异步执行完后在microtask queue中又注册了一个callback4回调函数</p><p><strong>Step 9</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这个回调函数叫做callback4，promise属于microtask，所以放到microtask queue中</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><p>Stack Queue: [promise]</p><p>Macrotask v: [callback3]</p><p>Microtask Queue: [callback4]</p><blockquote><p>打印结果：<br>1<br>4<br>7<br>5<br>2</p></blockquote><ul><li>取出一个宏任务macrotask执行完毕，然后再去微任务队列microtask queue中依次取出执行</li></ul><p><strong>Step 10</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></div><p>Stack Queue: [callback4]</p><p>Macrotask Queue: [callback3]</p><p>Microtask Queue: []</p><blockquote><p>打印结果：<br>1<br>4<br>7<br>5<br>2<br>3</p></blockquote><ul><li>微任务队列全部执行完，再去宏任务队列中取第一个任务执行</li></ul><p><strong>Step 11</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">6</span>)</span><br></pre></td></tr></table></figure></div><p>Stack Queue: [callback3]</p><p>Macrotask Queue: []</p><p>Microtask Queue: []</p><blockquote><p>打印结果：<br>1<br>4<br>7<br>5<br>2<br>3<br>6</p></blockquote><ul><li>以上，全部执行完后，Stack Queue为空，Macrotask Queue为空，Micro Queue为空</li></ul><p>Stack Queue: []</p><p>Macrotask Queue: []</p><p>Microtask Queue: []</p><blockquote><p>最终打印结果：<br>1<br>4<br>7<br>5<br>2<br>3<br>6</p></blockquote><p><strong>在执行微队列microtask queue中任务的时候，如果又产生了microtask，那么会继续添加到队列的末尾，也会在这个周期执行，直到microtask queue为空停止。</strong></p><p>注：当然如果你在microtask中不断的产生microtask，那么其他宏任务macrotask就无法执行了，但是这个操作也不是无限的</p><p>未完待续…</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex的使用及原理</title>
    <url>/posts/2ff2666.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 02 2020 23:48:26 GMT+0800 (GMT+08:00) --><h2 id="Vuex-是什么？"><a href="#Vuex-是什么？" class="headerlink" title="Vuex 是什么？"></a>Vuex 是什么？</h2><p>在理解Vuex的使用和原理之前首先要知道Vuex是什么？按照官方的说法，Vuex是专门为Vuejs应用程序设计的一款状态管理模式，类似于React中的Redux。它采用集中式存储管理应用的所有组件的状态。</p><a id="more"></a><h2 id="Vuex-的构成"><a href="#Vuex-的构成" class="headerlink" title="Vuex 的构成"></a>Vuex 的构成</h2><p>下面图片很清晰的展示出了Vuex的组成结构</p><p><img src="/posts/2ff2666/vuexliu.jpg" alt></p><ul><li><p>state<br><code>state</code> 是 Vuex 的数据中心，也就是说<code>state</code>是用来存储数据的。</p></li><li><p>Getters<br><code>getters</code> 和 组件的 <code>computed</code> 类似，方便直接生成一些可以直接用的数据。当组装的数据要在多个页面使用时，就可以使用 <code>getters</code> 来做。</p></li><li><p>Mutations<br><code>mutations</code>提交更改数据，使用<code>store.commit</code>方法更改<code>state</code>存储的状态。</p></li><li><p>Actions<br><code>Action</code> 提交的是 <code>mutation</code>，而不是直接变更状态。<code>Action</code> 可以包含任意异步操作。</p></li></ul><h2 id="Vuex的使用方式"><a href="#Vuex的使用方式" class="headerlink" title="Vuex的使用方式"></a>Vuex的使用方式</h2><ul><li><p>安装Vuex<br>方式一： npm 方式</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">npm install vuex --save</span><br></pre></td></tr></table></figure></div><p>方式二： yarn 方式</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">yarn add vuex</span><br></pre></td></tr></table></figure></div></li><li><p>在应用中引入Vuex</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure></div></li><li><p>在 Vue 组件中获得 Vuex 状态(State)</p></li></ul><p><strong>方式一： this.$store.state获取</strong></p><p>通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">	template: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">	computed: &#123;</span><br><span class="line">		count () &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>方式二： mapState 辅助函数获取（推荐）</strong></p><p>当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">"vuex"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: mapState(&#123;</span><br><span class="line">	<span class="comment">// 箭头函数可使代码更简练</span></span><br><span class="line">	count: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 传字符串参数 'count' 等同于 `state =&gt; state.count`</span></span><br><span class="line">	countAlias: <span class="string">'count'</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span></span><br><span class="line">	countPlusLocalState (state) &#123;</span><br><span class="line">		<span class="keyword">return</span> state.count + <span class="keyword">this</span>.localCount</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">	<span class="comment">// 映射 this.count 为 store.state.count</span></span><br><span class="line">	<span class="string">'count'</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure></div><ul><li>Getter的获取方式<br>有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数：</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">	doneTodosCount () &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.$store.state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done).length</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。</p><p><code>Vuex</code> 允许我们在 <code>store</code> 中定义”getter”（可以认为是 <code>store</code> 的计算属性）。就像计算属性一样，<code>getter</code> 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p><p><strong>方式一： 通过属性访问</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">store.getters.doneTodos</span><br></pre></td></tr></table></figure></div><p><strong>方式二： 通过方法访问</strong></p><p>你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> getTodoById: <span class="function">(<span class="params">state</span>) =&gt;</span> <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> state.todos.find(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id === id)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">store.getters.getTodoById(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></div><p>注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。</p><p><strong>方式三： mapGetters 辅助函数获取（推荐）</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  computed: &#123;</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span></span><br><span class="line">	...mapGetters([</span><br><span class="line">	  <span class="string">'doneTodosCount'</span>,</span><br><span class="line">	  <span class="string">'anotherGetter'</span>,</span><br><span class="line">	  <span class="comment">// ...</span></span><br><span class="line">	])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>如果你想将一个 getter 属性另取一个名字，使用对象形式：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">mapGetters(&#123;</span><br><span class="line">  <span class="comment">// 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`</span></span><br><span class="line">  doneCount: <span class="string">'doneTodosCount'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><ul><li>Mutation使用方式</li></ul><p>上面我们说了更改 Vuex 的 <code>store</code> 中的状态的唯一方法是提交 <code>mutation</code>，Vuex 中的 <code>mutation</code> 非常类似于事件：每个 <code>mutation</code> 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 <code>state</code> 作为第一个参数。</p><p><strong>使用常量替代 Mutation 事件类型</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mutation-types.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SOME_MUTATION = <span class="string">'SOME_MUTATION'</span></span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> &#123; SOME_MUTATION &#125; <span class="keyword">from</span> <span class="string">'./mutation-types'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">	<span class="comment">// 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span></span><br><span class="line">	[SOME_MUTATION] (state) &#123;</span><br><span class="line">	  <span class="comment">// mutate state</span></span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><p>当然使用常量代替Mutation事件类型也不是必须的，如果你不喜欢，你完全可以不这样做。</p><p><strong>在组件中提交 Mutation</strong></p><p>你可以在组件中使用 <code>this.$store.commit(&#39;xxx&#39;)</code> 提交 <code>mutation</code>，或者使用 <code>mapMutations</code> 辅助函数将组件中的 <code>methods</code> 映射为 store.commit 调用（需要在根节点注入 store）。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">	...mapMutations([</span><br><span class="line">	  <span class="string">'increment'</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.commit('increment')`</span></span><br><span class="line"></span><br><span class="line">	  <span class="comment">// `mapMutations` 也支持载荷：</span></span><br><span class="line">	  <span class="string">'incrementBy'</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`</span></span><br><span class="line">	]),</span><br><span class="line">	...mapMutations(&#123;</span><br><span class="line">	  add: <span class="string">'increment'</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.commit('increment')`</span></span><br><span class="line">	&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>Action使用方式</li></ul><p><strong>Action的注册</strong></p><p><code>Action</code> 函数接受一个与 store 实例具有相同方法和属性的 <code>context</code> 对象，因此你可以调用 context.commit 提交一个 <code>mutation</code>，或者通过 context.state 和 context.getters 来获取 state 和 getters。当我们在之后介绍到 <code>Modules</code> 时，你就知道 <code>context</code> 对象为什么不是 store 实例本身了。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><p><strong>分发 Action</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以载荷形式分发</span></span><br><span class="line">store.dispatch(<span class="string">'incrementAsync'</span>, &#123;</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以对象形式分发</span></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="string">'incrementAsync'</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><p><strong>在组件中分发 Action</strong></p><p>你在组件中使用 this.$store.dispatch(‘xxx’) 分发 <code>action</code>，或者使用 <code>mapActions</code> 辅助函数将组件的 <code>methods</code> 映射为 <code>store.dispatch</code> 调用（需要先在根节点注入 store）</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([</span><br><span class="line">      <span class="string">'increment'</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// `mapActions` 也支持载荷：</span></span><br><span class="line">      <span class="string">'incrementBy'</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`</span></span><br><span class="line">    ]),</span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">      add: <span class="string">'increment'</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.dispatch('increment')`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>请各位多提意见，如有遗漏，后续补齐</strong></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript/apply、call和bind方法</title>
    <url>/posts/384c131e.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 02 2020 23:48:26 GMT+0800 (GMT+08:00) --><h2 id="三者的相似之处"><a href="#三者的相似之处" class="headerlink" title="三者的相似之处"></a>三者的相似之处</h2><ol><li>都是用来改变函数的 this 对象的指向的。</li><li>第一个参数都是 this 要指向的对象。</li><li>都可以利用后续参数传参。<a id="more"></a></li></ol><h2 id="apply-方法"><a href="#apply-方法" class="headerlink" title="apply 方法"></a>apply 方法</h2><p>apply 的使用语法：</p><blockquote><p>函数名字.apply(对象,[参数 1,参数 2,…]);<br>方法名字.apply(对象,[参数 1,参数 2,…]);<br>apply 方法是以数组的方式传递参数</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取按钮</span></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.btn'</span>)</span><br><span class="line"><span class="comment">// 使用apply方法,改变Array中forEach方法的指向,循环遍历解析按钮注册点击事件</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.forEach.apply(btn, [</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">    addEventListener(ele, <span class="string">'click'</span>, clickHandle)</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是window对象的方法:'</span> + (x + y) + <span class="keyword">this</span>.sex)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.fn(<span class="number">50</span>, <span class="number">60</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  age: <span class="number">10</span>,</span><br><span class="line">  sex: <span class="string">'男'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.fn.apply(obj, [<span class="number">10</span>, <span class="number">20</span>]) <span class="comment">//30男</span></span><br></pre></td></tr></table></figure></div><p>无论是系统构造函数的方法，还是自己定义的函数方法，都可以通过 apply 方法来改变 this 的指向</p><h2 id="call-方法"><a href="#call-方法" class="headerlink" title="call 方法"></a>call 方法</h2><p>call 的使用语法：</p><blockquote><p>函数名字.call(对象,参数 1,参数 2,…);<br>方法名字.call(对象,参数 1,参数 2,…);<br>call 方法是以字符串形式传递参数</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取所有的点赞标签</span></span><br><span class="line"><span class="keyword">var</span> praise = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.praise'</span>)</span><br><span class="line"><span class="comment">// 使用call方法,改变Array中forEach方法的指向,遍历点赞标签，注册点击事件</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(praise, <span class="function"><span class="keyword">function</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">  addEventListener(ele, <span class="string">'click'</span>, praHandle)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是window对象的方法:'</span> + (x + y) + <span class="keyword">this</span>.sex)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.fn(<span class="number">50</span>, <span class="number">60</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  age: <span class="number">10</span>,</span><br><span class="line">  sex: <span class="string">'男'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.fn.call(obj, <span class="number">10</span>, <span class="number">50</span>) <span class="comment">//60男</span></span><br></pre></td></tr></table></figure></div><p>无论是系统构造函数的方法，还是自己定义的函数方法，都可以通过 call 方法来改变 this 的指向</p><h2 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind 方法"></a>bind 方法</h2><blockquote><p>bind 方法是复制的意思,参数可以在复制的时候传进去,也可以在复制之后调用的时候传入进去<br>apply 和 call 是调用的时候改变 this 指向<br>bind 方法,是赋值一份的时候,改变了 this 的指向</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 人的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加原型方法</span></span><br><span class="line">Person.prototype.play = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span> + <span class="string">'====&gt;'</span> + <span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 学生的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化对象</span></span><br><span class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> Person(<span class="number">60</span>)</span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> Student(<span class="number">80</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过bind方法赋值一份</span></span><br><span class="line"><span class="keyword">var</span> ff = per.play.bind(stu)</span><br><span class="line">ff()</span><br></pre></td></tr></table></figure></div><ul><li>bind 是用来复制一份</li></ul><p>使用的语法:</p><blockquote><p>函数名字.bind(对象,参数 1,参数 2,…);—-&gt;返回值是复制之后的这个函数<br>方法名字.bind(对象,参数 1,参数 2,…);—-&gt;返回值是复制之后的这个方法</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的异步</title>
    <url>/posts/5cd28b9d.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 02 2020 23:48:26 GMT+0800 (GMT+08:00) --><h2 id="异步出现的前提"><a href="#异步出现的前提" class="headerlink" title="异步出现的前提"></a>异步出现的前提</h2><p>首先，因为JavaScript语言是单线程的<strong>(目标为浏览器端，出生即为单线程)</strong>,所以就需要异步，否则JavaScript脚本智能自上而下执行，如果在上部存在一些极其复杂的代码需要解析很长的时间的话，下面的代码就会遭到阻塞，也就是用户感受到的卡死.</p><h2 id="异步如何实现"><a href="#异步如何实现" class="headerlink" title="异步如何实现"></a>异步如何实现</h2><p>由于是单线程语言，所以JavaScript实现异步的方法是通过<strong>事件循环(event loop)</strong>来实现异步.</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'I’m first one code!'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I’m setTimeout function code!'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'I’m last one code! '</span>);</span><br></pre></td></tr></table></figure></div><p>这段代码的运行结果为</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">I’m first one code!</span><br><span class="line">I’m last one code!</span><br><span class="line">I’m setTimeout <span class="keyword">function</span> code!</span><br></pre></td></tr></table></figure></div><p>所以，代码并没有是自上而下执行，setTimeout函数是延迟了一段时间，等其他语句执行完了采取执行，这种情况就为异步。</p><h3 id="eventloop的机制"><a href="#eventloop的机制" class="headerlink" title="eventloop的机制"></a>eventloop的机制</h3><p>根据上一部分我们知道，JavaScript把事件分为两类:同步与异步</p><p>所以JavaScript的执行机制其实是:</p><ul><li>判断一个任务是同步任务还是异步任务，同步进入主线程，异步进入event table</li><li>异步任务在event table中注册函数，满足该函数触发条件后，推入事件队列</li><li>同步任务在主线程按顺序执行，当主线程空闲时，再去事件队列中查看是否有可执行的异步任务，如果有就进入主线程</li></ul><p><strong>这个循环即为 event loop</strong></p><h3 id="异步也有小区别"><a href="#异步也有小区别" class="headerlink" title="异步也有小区别"></a>异步也有小区别</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">&#125;).then( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br></pre></td></tr></table></figure></div><p>如果按照我们刚才的理解，这段代码的结果应该为 2,4,1,3</p><p>但是很不幸的是，他的结果为 2,4,3,1<br>这也引入了另外两个概念：<strong>宏任务与微任务</strong></p><p>所以任务应该分为这两类:</p><ul><li>宏任务(macro-task): 包括整段script代码,<code>setTimeout</code>,<code>setInterval</code></li><li>微任务(micro-task): <code>Promise，catch， finally，process.nextTick(Node端)</code></li></ul><p>所以js的执行机制其实是:<br>先执行一个宏任务，过程中如果遇到微任务先把他放到微任务的事件队列中,当宏任务执行完毕后，再去查看微任务的事件队列，将微任务一次执行完，执行完毕后再去进行下一个队列的宏任务,以此循环.</p><p>借用一张图演示</p><p><img src="/posts/5cd28b9d/event-loop.jpg" alt></p><h2 id="介绍主角Async"><a href="#介绍主角Async" class="headerlink" title="介绍主角Async"></a>介绍主角Async</h2><p><code>async</code>，一个在ES2017中提出的异步方案，有人说他是<code>Generator</code>函数的语法糖，只是把<code>Generator</code>函数的 * 替换为 <code>async</code>，把yield替换为await。我们先不讨论这句话说得对不对:speak_no_evil:,但它确实是基于了<code>Generator</code>的一种改进，它让异步变得更简单了。</p><h3 id="他做了什么"><a href="#他做了什么" class="headerlink" title="他做了什么?"></a>他做了什么?</h3><p>如果要简述的话，一旦你的函数前带上了async,你的函数返回值就必定是promise对象.(他就像真香定律一样是没有可以逃过的)就算你写的函数里返回的不是promise，他也会自动用Promise.resolve()包装起来让他成为一个promise对象。<br>所以，如果我们简单理解<code>async</code>关键字的话，他其实就是给函数加上一个标识，说明这个函数内部有异步操作。</p><h2 id="What-is-await-waiting-for"><a href="#What-is-await-waiting-for" class="headerlink" title="What is await waiting for?"></a>What is await waiting for?</h2><p>我们再次简单的介绍以下 await，await 其实等的是右侧表达式的结果.</p><blockquote><p>如果右侧是一个函数，则是这个函数的返回值。如果是一个值则就为此值.</p></blockquote><p>我们通过一个例子来”见识见识”它</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fun1 is started!'</span>);</span><br><span class="line">    <span class="keyword">await</span> fun2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fun1 ending!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fun2 is running!'</span>);</span><br><span class="line">&#125;</span><br><span class="line">fun1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br></pre></td></tr></table></figure></div><p>我们知道，await是通过执行到此时让出线程，通过阻塞后面的代码来执行，但我们执行上面的代码发现结果为</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">fun1 is started!</span><br><span class="line">fun2 is running!</span><br><span class="line">script start</span><br><span class="line">fun1 endding!</span><br></pre></td></tr></table></figure></div><p>注意，这里fun2先于”script start” 执行，所以 <code>await</code> 的那个表达式的执行顺序其实是从右到左，即为执行了fun2后读到了<code>await</code>关键字，然后阻塞后面的代码，这点非常重要，因为之前因为”一旦遇到<code>await</code>就立马退出线程，阻塞后面的代码”的观点，认为 <code>await</code>也会阻塞他后面的那个表达式，但其实不然。</p><blockquote><p>await 与 async 的关系就像鱼和水， await必须要有async才可以存在，而async却不一定需要有await。</p></blockquote><h2 id="await-的下一步操作"><a href="#await-的下一步操作" class="headerlink" title="await 的下一步操作"></a>await 的下一步操作</h2><p>一般来说 await等到的右侧表达式结果有两种情况：</p><p>Promise or Not Promise。</p><ul><li>如果不是promise，await会阻塞之后的代码，就先去执行async外面的同步代码，同步代码执行完后再回到async内部，把这个不是promise的结果作为await的结果。</li><li>如果是promise对象，await也会先阻塞async后面的代码，然后执行async外面的同步代码，等待这个promise对象到达fulfilled状态后，把 resolve 的参数作为 await的运算结果。其实就是执行了await Promise.resolve()，这里不做详细解释.</li></ul><h2 id="Async-与-Promise-和-Generator的一些比较"><a href="#Async-与-Promise-和-Generator的一些比较" class="headerlink" title="Async 与 Promise 和 Generator的一些比较"></a>Async 与 Promise 和 Generator的一些比较</h2><ul><li>首先Promise的提出是解决了之前令人头疼的回调地狱(callback hell)问题，但直观的看上去其实就像用了一个类库，通过Promise的api来完成了异步操作，操作本身的可调控性不是很高，但已经很实用了。</li><li>Generator函数的语义相较于Promise清晰了许多，但问题就是如果他要自动执行的话必须实用任务运行器来自动执行它。</li><li>Async相较于Generator函数实现起来相对简洁，更贴切语义。它在语言层面提供了Generator的自动执行器，代码量也大大减少。</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript 6 标准入门</a><br><a href="https://www.cnblogs.com/jiasm/p/9482443.html" target="_blank" rel="noopener">微任务、宏任务与Event-Loop</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>《掌控习惯》读后感</title>
    <url>/posts/a0834705.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 02 2020 23:48:26 GMT+0800 (GMT+08:00) --><p>很多人想养成早起阅读的好习惯，也有很多人想要戒烟戒酒，摒除一些坏的习惯，但我们往往会半途而废，导致我们丧失信心，没有了继续下去的勇气。最近读了一本书，叫《掌控习惯》，为什么大家的好习惯一直难以养成，为什么大家的坏习惯很难戒除，其实不是我们没有决心，只是我们用错了方法。</p><a id="more"></a><p><img src="http://blog.yptup.top/new-old.jpeg" alt></p><p>大家先想一想自己有哪些坏习惯，有人会说我沉迷网络游戏，有人会说，我喜欢抽烟，还有大部分大学生都普遍有一个坏习惯，那就是熬夜。我们先来分析一下，沉迷网络游戏这个坏习惯，网络游戏它是一个什么机制呢？它是一种让人上瘾的机制，你在击杀一个敌人，或者赢得一次比赛之后，当时你就会感到特别的喜悦也就是说你获得的快乐，获得的满足感，是有即刻性的。于是我们慢慢的喜欢上了这种感觉，一次又一次的重复，我们便沉迷上了网络游戏。其实我们沉迷的并不是网络游戏，而是沉迷在完成网络游戏之后即可获得的喜悦感。现在大家再来看看，抽烟和熬夜，是不是也有相同的性质呢？</p><p><img src="http://blog.yptup.top/game.jpeg" alt></p><p>我们都很想去养成一个很好的习惯，有人想要让自己习惯于健身，有人想要习惯于让自己早起，我们往往会发现这些习惯是很不容易养成的，每次健身之后，你不会很明显的看到自己身上多了一块儿腹肌，或者你的胳膊变得更粗壮了，健身便失去了即刻的满足感，在一次两次三次健身之后，我们都无法获得自己想要的结果，于是我们的内心就会告诉我们放弃吧，健身，没有很好的效果，意志力相对薄弱的人，会马上放弃，而一些意志力比较强一些的人，他们会坚持一段时间以后选择放弃，一个好习惯便被无情的终止了。</p><p><img src="http://blog.yptup.top/timg.jpg" alt></p><p>相信很多人看到这里已经对好习惯和坏习惯，有了大致的了解，也有很多人已经在为养成一个好习惯，找到了一个大致的方向，下面给大家介绍一个养成好习惯的方法：早起之后给自己画一个美美的妆;健身以后，奖励自己拿出手机，看一看朋友圈;阅读之后奖励自己一杯咖啡，这就叫喜好绑定法。在完成一个自己想要坚持的习惯以后，给自己一个小小的奖励，让自己获得即刻的满足感，我们对这个习惯的坚持便多了一份喜悦。</p><p><img src="http://blog.yptup.top/coffee.jpeg" alt></p><p>想象一下，你每天早上起床之后，可以给自己画美美的妆，是不是很开心呢?我们大家都希望开心，养成属于我们自己的好习惯，让我们的生活更加美丽。</p><p><img src="http://blog.yptup.top/sunshine.jpeg" alt></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>爱读书</category>
      </categories>
      <tags>
        <tag>爱读书</tag>
      </tags>
  </entry>
</search>
