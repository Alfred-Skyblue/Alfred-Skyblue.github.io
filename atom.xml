<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JavaScript</title>
  
  <subtitle>每一个不曾起舞的日子，都是对生命的辜负</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-22T02:37:18.486Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>丶远方</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS数组常用技巧</title>
    <link href="http://yoursite.com/posts/133a37.html"/>
    <id>http://yoursite.com/posts/133a37.html</id>
    <published>2020-02-22T01:23:55.000Z</published>
    <updated>2020-02-22T02:37:18.486Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 23 2020 16:26:55 GMT+0800 (GMT+08:00) --><p><canter>你必须知道的JS数组技巧</canter></p><p>在Javascript中，数组是一个重要且常见的知识点，我们经常将数据存储在数组中。作为一名Javascript工程师，数组必须要运用自如。这篇文章，向大家展示了在日常开发中，数组有哪些奇淫技巧值得关注和学习，让我们开始吧！</p><h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><p>怎么对JS的数组去重。在ES6的时代，有个非常快速且简单的方法，使用<code>new Set()</code>以及<code>Array.from()</code>或者<code>展开运算符(...)</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">'banana'</span>, <span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'watermelon'</span>, <span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'grape'</span>, <span class="string">'apple'</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">var</span> uniqueFruits = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(fruits));</span><br><span class="line"><span class="built_in">console</span>.log(uniqueFruits); <span class="comment">// returns ['banana', 'apple', 'orange', 'watermelon', 'grape']</span></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">var</span> uniqueFruits2 = […<span class="keyword">new</span> <span class="built_in">Set</span>(fruits)];</span><br><span class="line"><span class="built_in">console</span>.log(uniqueFruits2); <span class="comment">// returns ['banana', 'apple', 'orange', 'watermelon', 'grape']</span></span><br></pre></td></tr></table></figure></div><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>日常开发中经常需要替换或者删除一些指定的数据，遇到这种场景时一定要联想到<code>Array.protoType.splice</code>这个方法。传参时稍微复杂点，第一个参数是开始的索引，第二个参数是需要删除的数量，剩下的就是需要添加的值（可以是一个或者多个）。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">'banana'</span>, <span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'watermelon'</span>, <span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'grape'</span>, <span class="string">'apple'</span>];</span><br><span class="line">fruits.splice(<span class="number">0</span>, <span class="number">2</span>, <span class="string">'potato'</span>, <span class="string">'tomato'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fruits); <span class="comment">// returns ['potato', 'tomato', 'orange', 'watermelon', 'apple', 'orange', 'grape', 'apple']</span></span><br></pre></td></tr></table></figure></div><h2 id="清空数组"><a href="#清空数组" class="headerlink" title="清空数组"></a>清空数组</h2><p>有时我们需要清空一个数组，比如用户点击了清空购物车。可以一条一条地删除，但是很少有这么可爱的程序员，哈哈。其实一行代码就能搞定，那就是直接将之length设置成0</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">'banana'</span>, <span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'watermelon'</span>, <span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'grape'</span>, <span class="string">'apple'</span>];</span><br><span class="line"></span><br><span class="line">fruits.length = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(fruits); <span class="comment">// returns []</span></span><br></pre></td></tr></table></figure></div><h2 id="数组转换成对象"><a href="#数组转换成对象" class="headerlink" title="数组转换成对象"></a>数组转换成对象</h2><p>有时候需要将数组转换成对象的形式，使用<code>.map()</code>一类的迭代方法能达到目的，这里还有个更快的方法，前提是你正好希望对象的key就是数组的索引</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">'banana'</span>, <span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'watermelon'</span>];</span><br><span class="line"><span class="keyword">var</span> fruitsObj = &#123; …fruits &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(fruitsObj); <span class="comment">// returns &#123;0: 'banana', 1: 'apple', 2: 'orange', 3: 'watermelon', 4: 'apple', 5: 'orange', 6: 'grape', 7: 'apple'&#125;</span></span><br></pre></td></tr></table></figure></div><h2 id="填充数组"><a href="#填充数组" class="headerlink" title="填充数组"></a>填充数组</h2><p>创建数组的时候，你有没有遇到过需要填充上默认值的场景，你肯定首先想到的就是循环这个数组。ES6提供了更便捷的<code>fill</code>方法</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newArray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>).fill(<span class="string">'1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newArray); <span class="comment">// returns ['1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1']</span></span><br></pre></td></tr></table></figure></div><h2 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h2><p>你知道如何合并数组吗，答案就是<code>concat()</code>。哈哈，但是今天的主角是ES6的展开运算符<code>(...)</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'orange'</span>];</span><br><span class="line"><span class="keyword">var</span> meat = [<span class="string">'poultry'</span>, <span class="string">'beef'</span>, <span class="string">'fish'</span>];</span><br><span class="line"><span class="keyword">var</span> vegetables = [<span class="string">'potato'</span>, <span class="string">'tomato'</span>, <span class="string">'cucumber'</span>];</span><br><span class="line"><span class="keyword">var</span> food = […fruits, …meat, …vegetables];</span><br><span class="line"><span class="built_in">console</span>.log(food); <span class="comment">// ['apple', 'banana', 'orange', 'poultry', 'beef', 'fish', 'potato', 'tomato', 'cucumber']</span></span><br></pre></td></tr></table></figure></div><h2 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h2><p>方法很多，这里直接上最简洁的方法</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numOne = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">var</span> numTwo = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> duplicatedValues = […<span class="keyword">new</span> <span class="built_in">Set</span>(numOne)].filter(<span class="function"><span class="params">item</span> =&gt;</span> numTwo.includes(item));</span><br><span class="line"><span class="built_in">console</span>.log(duplicatedValues); <span class="comment">// returns [2, 4, 6]</span></span><br></pre></td></tr></table></figure></div><h2 id="去除假值"><a href="#去除假值" class="headerlink" title="去除假值"></a>去除假值</h2><p>首先，我们熟悉下假值<code>(falsy values)</code>是什么？在JS中，假值有：<code>false、0、&#39;&#39;、null、NaN、undefined</code>。现在我们找到这些假值并将它们移除，这里使用的是<code>filter</code>方法</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mixedArr = [<span class="number">0</span>, <span class="string">'blue'</span>, <span class="string">''</span>, <span class="literal">NaN</span>, <span class="number">9</span>, <span class="literal">true</span>, <span class="literal">undefined</span>, <span class="string">'white'</span>, <span class="literal">false</span>];</span><br><span class="line"><span class="keyword">var</span> trueArr = mixedArr.filter(<span class="built_in">Boolean</span>);</span><br><span class="line"><span class="built_in">console</span>.log(trueArr); <span class="comment">// returns ['blue', 9, true, 'white']</span></span><br></pre></td></tr></table></figure></div><h2 id="随机值"><a href="#随机值" class="headerlink" title="随机值"></a>随机值</h2><p>从数组中获取随机的一个值，核心知识是随机生成一个值x,x &gt;= 0 并且 x &lt; 数组的length</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">'blue'</span>, <span class="string">'white'</span>, <span class="string">'green'</span>, <span class="string">'navy'</span>, <span class="string">'pink'</span>, <span class="string">'purple'</span>, <span class="string">'orange'</span>, <span class="string">'yellow'</span>, <span class="string">'black'</span>, <span class="string">'brown'</span>];</span><br><span class="line"><span class="keyword">var</span> randomColor = colors[(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (colors.length)))]</span><br></pre></td></tr></table></figure></div><h2 id="倒序"><a href="#倒序" class="headerlink" title="倒序"></a>倒序</h2><p>怎么对数组进行倒序？只需要一行代码</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">'blue'</span>, <span class="string">'white'</span>, <span class="string">'green'</span>, <span class="string">'navy'</span>, <span class="string">'pink'</span>, <span class="string">'purple'</span>, <span class="string">'orange'</span>, <span class="string">'yellow'</span>, <span class="string">'black'</span>, <span class="string">'brown'</span>];</span><br><span class="line"><span class="keyword">var</span> reversedColors = colors.reverse();</span><br><span class="line"><span class="comment">// 或者 colors.slice().reverse();</span></span><br><span class="line"><span class="comment">// 两者有啥区别？</span></span><br><span class="line"><span class="built_in">console</span>.log(reversedColors); <span class="comment">// returns ['brown', 'black', 'yellow', 'orange', 'purple', 'pink', 'navy', 'green', 'white', 'blue']</span></span><br></pre></td></tr></table></figure></div><h2 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h2><p>很多时候我们查找元素是否存在于某个数组中，经常使用<code>indexOf</code>方法，常常忽略<code>lastIndexOf</code>方法，后者会被使用的一个场景就是，某个数组中有重复的数据。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">var</span> lastIndex = nums.lastIndexOf(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(lastIndex); <span class="comment">// returns 9</span></span><br></pre></td></tr></table></figure></div><h2 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h2><p>答案也是很多，条条大道通罗马，这里使用的是<code>reduce</code>，<code>reduce</code>方法是很值得学习的知识点，用处很多。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> sum = nums.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y);</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// returns 14</span></span><br></pre></td></tr></table></figure></div><p>本文主要列举了一些简洁的方法，实现方法很多，不在此一一列举<br>未完待续…</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Feb 23 2020 16:26:55 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;canter&gt;你必须知道的JS数组技巧&lt;/canter&gt;&lt;/p&gt;&lt;p&gt;在Javascript中，数组是一个重要且常见的知识点，我们经常将数据存
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>页面性能优化</title>
    <link href="http://yoursite.com/posts/d333b549.html"/>
    <id>http://yoursite.com/posts/d333b549.html</id>
    <published>2020-02-21T12:19:27.000Z</published>
    <updated>2020-02-22T01:13:55.462Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 23 2020 16:26:56 GMT+0800 (GMT+08:00) --><p><canter>优化前端性能，提升用户体验，一直是从事前端工作人员必须考虑的问题，之前参考过很多资料，大多说的不是很详细，重点描述的也不是很到位，鄙人不才，愿集百家之所长，供大家参考(其实大概意思就是本文非本人原创，都是参考自别人的资料，由于资源来自四面八方，就不在这里一一列举了)</canter></p><h2 id="性能优化概述"><a href="#性能优化概述" class="headerlink" title="性能优化概述"></a>性能优化概述</h2><p><strong>从输入 URL 到页面加载完成，完整的链路</strong></p><p><img src="http://q61y3rbwd.bkt.clouddn.com/gaishu.webp" alt></p><ol><li>DNS 解析</li><li>TCP 连接</li><li>HTTP 请求抛出</li><li>服务端处理请求，HTTP 响应返回</li><li>浏览器拿到响应数据，解析响应内容，把解析的结果展示给用户</li></ol><h2 id="整个性能消化"><a href="#整个性能消化" class="headerlink" title="-整个性能消化"></a>-整个性能消化</h2><p><img src="http://q61y3rbwd.bkt.clouddn.com/xingneng.webp" alt></p><h2 id="HTTP层面优化"><a href="#HTTP层面优化" class="headerlink" title="HTTP层面优化"></a>HTTP层面优化</h2><ul><li>DNS 解析:<br>DNS 实现域名到IP的映射。通过域名访问站点，每次请求都要做DNS解析。目前每次DNS解析，通常在200ms以下。一般采用DNS Prefetch 一种DNS 预解析技术，当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行DNS的解析，减少用户等待时间，提高用户体验。</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"dns-prefetch"</span> href=<span class="string">"www.baidu.com"</span> /&gt; </span><br><span class="line"> <span class="comment">// 只支持部分浏览器</span></span><br></pre></td></tr></table></figure></div><ul><li><p>TCP 连接：<br>采用http2.0，可以复用tcp通道，采用二进制格式而非文本格式，使用报头压缩，HTTP/2降低了开销，支持cache push</p></li><li><p>浏览器并发<br>基于端口跟线程切换开销，浏览器不可能无限的并发请求。chrome的并发为6，超过限制数目的请求就会被阻塞；<br>对于某些静态资源，图片等等，我们可以对其URL分散处理 ，不同的资源域名(部署在cdn上)。</p></li><li><p>http请求次数<br>减少http的请求次数，将多个请求合并成同一个，减少http的开销</p></li><li><p>webpack<br>充分利用webpack提供给我们的能力，利用DllPlugin与commonPlugins等插件对我们代码进行<br>优化，文件的分割与合并，公共代码的提取，长缓存等策略</p></li><li><p>HTTP压缩<br>采用Gzip压缩：HTTP 压缩就是以缩小体积为目的，对 HTTP 内容进行重新编码的过程，原理是找出一些重复出现的字符串、临时替换它们，从而使整个文件变小，文件中代码的重复率越高，那么压缩的效率就越高，使用 Gzip 的收益也就越大</p></li></ul><h2 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h2><p><img src="http://q61y3rbwd.bkt.clouddn.com/img.webp" alt></p><h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><ul><li>强缓存：<br>浏览器在请求某一资源时，会先获取该资源缓存的header信息，判断是否命中强缓存（cache-control和expires信息），若命中直接从缓存中获取资源信息，包括缓存header信息；本次请求根本就不会与服务器进行通信</li></ul><ol><li><p>expires:这是http1.0时的规范；它的值为一个绝对时间的GMT格式的时间字符串，如Mon, 10 Jun 2015 21:31:12 GMT，如果发送请求的时间在expires之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源</p></li><li><p>cache-control：max-age=number，这是http1.1时出现的header信息，主要是利用该字段的max-age值来进行判断，它是一个相对值；资源第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；cache-control除了该字段外，还有下面几个比较常用的设置值：no-cache ，no-store，public，private</p></li></ol><ul><li>协商缓存（对比缓存）</li></ul><ol><li>Last-Modified/If-Modified-Since:第一次请求，服务端在Response Headers ：Last-Modified:Fri, 27 Oct 2017 06:35:57 GMT，也就是服务端最后修改该资源的时间。浏览器再次跟服务器请求这个资源时，会在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值，服务器进行比较，如果相同则返回304，否则浏览器直接从服务器加载资源时，Last-Modified的Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值</li><li>Etag/If-None-Match: 服务器会为每个资源生成一个唯一的标识字符串，只要文件内容不同，它们对应的 Etag 就是不同的；If-Modified-Since能检查到的精度是s级的，某些服务器不能精确的得到文件的最后修改时间，我们编辑了文件，但文件的内容没有改变。因为服务器是根据文件的最后修改时间来判断的，导致重新请求所以才出现了Etag，Etag对服务器也有性能损耗</li></ol><blockquote><p>Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</p></blockquote><ul><li>请求过程总结：<br><img src="http://q61y3rbwd.bkt.clouddn.com/modified.webp" alt></li></ul><h2 id="浏览器渲染机制"><a href="#浏览器渲染机制" class="headerlink" title="浏览器渲染机制"></a>浏览器渲染机制</h2><ul><li><p>DOM树:<br>解析 HTML 以创建的是 DOM 树（DOM tree ）：渲染引擎开始解析 HTML 文档，转换树中的标签到 DOM 节点，它被称为“内容树”。</p></li><li><p>CSSOM树：<br>解析 CSS（包括外部 CSS 文件和样式元素）创建的是 CSSOM 树。CSSOM 的解析过程与 DOM 的解析过程是并行的。</p></li><li><p>渲染树：<br>CSSOM 与 DOM 结合，之后我们得到的就是渲染树（Render tree ）。</p></li><li><p>布局渲染树：<br>从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕上的精确坐标，我们便得到了基于渲染树的布局渲染树（Layout of the render tree）。</p></li><li><p>绘制渲染树:<br>遍历渲染树，每个节点将使用 UI 后端层来绘制。整个过程叫做绘制渲染树（Painting the render tree）。</p></li></ul><center class="color-ccc">渲染流程图</center><p><img src="http://q61y3rbwd.bkt.clouddn.com/Image.png" alt></p><h2 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h2><ul><li>普通模式，JS 会阻塞浏览器，浏览器必须等待 index.js 加载和执⾏完毕才能去做其它事情。一般将此类js放在在<code>body</code>标签的底部，减少对整个页面下载的影响</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"index.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></div><ul><li><p>async 模式：JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会立即执行，async模式没有执行顺序，先返回的优先执行，先到先得</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">"index.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></div></li><li><p>defer 模式：JS 的加载是异步的，执行是被推迟的。等整个文档解析完成DOMContentLoaded 事件即将被触发时，被标记了defer 的 JS 文件才会开始依次执行</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script defer src=<span class="string">"index.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></div></li></ul><p>一般当我们的脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。</p><ul><li>动态加载脚本：此文件当元素添加到页面之后立刻开始下载。无论在何处启动下载，文件的下载和运行都不会阻塞其他页面处理过程。甚至可以将这些代码放在<head>部分而不会对其余部分的页面代码造成影响</head></li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement (<span class="string">"script"</span>);</span><br><span class="line">   script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">   script.src = <span class="string">"script1.js"</span>;</span><br><span class="line">   <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(script);</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Feb 23 2020 16:26:56 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;canter&gt;优化前端性能，提升用户体验，一直是从事前端工作人员必须考虑的问题，之前参考过很多资料，大多说的不是很详细，重点描述的也不是很到位
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CSS3 transform 中的坑</title>
    <link href="http://yoursite.com/posts/f4adc94f.html"/>
    <id>http://yoursite.com/posts/f4adc94f.html</id>
    <published>2020-02-19T07:23:54.000Z</published>
    <updated>2020-02-19T07:43:09.485Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 23 2020 16:26:55 GMT+0800 (GMT+08:00) --><p>transform对普通元素的影响是个巨坑，自己亲身体验的总共有三点</p><blockquote><ol><li>提升元素的垂直地位，也就是z-index会变大</li><li>改变元素的定位属性，fixed变成absolute，absolute变成relative</li><li>使绝对定位(absolute)的子元素受父元素overflow:hidden的作用。（ps:绝对定位(absolute)的子元素宽度大于父元素，如果父容器的定位是static，也就是默认时，overflow:hidden无效）</li></ol></blockquote><p style="color:red">下面我们来看一下没有没有transform属性的状态</p><p><img src="/posts/f4adc94f/no-transform.png" alt="no-transform"></p><p>再来看一下给红色框增加transform属性后的状态</p><p><img src="/posts/f4adc94f/transform.png" alt="transform"></p><p>注:<br>CSS3新增的一些属性虽然才艺高超，但是在非必要的情况下，还是尽量不要用它<br>CSS3虽好，但是不要贪杯哦</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Feb 23 2020 16:26:55 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;transform对普通元素的影响是个巨坑，自己亲身体验的总共有三点&lt;/p&gt;&lt;blockquote&gt;&lt;ol&gt;&lt;li&gt;提升元素的垂直地位，也就是z
      
    
    </summary>
    
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="前端踩坑记" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Vue生命周期详解</title>
    <link href="http://yoursite.com/posts/6f7db675.html"/>
    <id>http://yoursite.com/posts/6f7db675.html</id>
    <published>2020-02-16T08:24:50.000Z</published>
    <updated>2020-02-22T01:16:39.089Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 23 2020 16:26:56 GMT+0800 (GMT+08:00) --><p>Vue实例有一个完整的生命周期，也就是说从开始创建、初始化数据、编译模板、挂在DOM、渲染-更新-渲染、卸载等一系列过程，我们成为Vue 实例的生命周期，钩子就是在某个阶段给你一个做某些处理的机会。</p><a id="more"></a><p><img src="http://q61l3an3n.bkt.clouddn.com/1700fc5ba6a36e6c%20%281%29.png" alt="生命周期图"></p><center><font color="#ccc">生命周期图</font></center><hr><p><img src="/posts/6f7db675/vue2.jpg" alt></p><ul><li><p>beforeCreate(创建前)<br>在实例初始化之后，数据观测和事件配置之前被调用，此时组件的选项对象还未创建，el 和 data 并未初始化，因此无法访问methods， data， computed等上的方法和数据。</p></li><li><p>created(创建后)<br>实例已经创建完成之后被调用，在这一步，实例已完成以下配置：数据观测、属性和方法的运算，watch/event事件回调，完成了data 数据的初始化，el没有。 然而，挂在阶段还没有开始, $el属性目前不可见，这是一个常用的生命周期，因为你可以调用methods中的方法，改变data中的数据，并且修改可以通过vue的响应式绑定体现在页面上，，获取computed中的计算属性等等，通常我们可以在这里对实例进行预处理，也有一些童鞋喜欢在这里发ajax请求，值得注意的是，这个周期中是没有什么方法来对实例化过程进行拦截的，因此假如有某些数据必须获取才允许进入页面的话，并不适合在这个方法发请求，建议在组件路由钩子beforeRouteEnter中完成</p></li><li><p>beforeMount<br>挂在开始之前被调用，相关的render函数首次被调用（虚拟DOM），实例已完成以下的配置： 编译模板，把data里面的数据和模板生成html，完成了el和data 初始化，注意此时还没有挂在html到页面上。</p></li><li><p>mounted<br>挂在完成，也就是模板中的HTML渲染到HTML页面中，此时一般可以做一些ajax操作，mounted只会执行一次。</p></li><li><p>beforeUpdate<br>在数据更新之前被调用，发生在虚拟DOM重新渲染和打补丁之前，可以在该钩子中进一步地更改状态，不会触发附加地重渲染过程</p></li><li><p>updated(更新后)<br>在由于数据更改导致地虚拟DOM重新渲染和打补丁只会调用，调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作，然后在大多是情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环，该钩子在服务器端渲染期间不被调用</p></li><li><p>beforeDestrioy(销毁前)<br>在实例销毁之前调用，实例仍然完全可用，</p></li></ul><ol><li>这一步还可以用this来获取实例</li><li>一般在这一步做一些重置的操作，比如清除掉组件中的定时器 和 监听的dom事件</li></ol><ul><li>destroyed(销毁后)<br>在实例销毁之后调用，调用后，所以的事件监听器会被移出，所有的子实例也会被销毁，该钩子在服务器端渲染期间不被调用</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Feb 23 2020 16:26:56 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;Vue实例有一个完整的生命周期，也就是说从开始创建、初始化数据、编译模板、挂在DOM、渲染-更新-渲染、卸载等一系列过程，我们成为Vue 实例的生命周期，钩子就是在某个阶段给你一个做某些处理的机会。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>构造函数</title>
    <link href="http://yoursite.com/posts/1688ec4d.html"/>
    <id>http://yoursite.com/posts/1688ec4d.html</id>
    <published>2020-02-15T12:52:15.316Z</published>
    <updated>2020-02-22T02:40:45.793Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 23 2020 16:26:56 GMT+0800 (GMT+08:00) --><p>摘要内容</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数是一种特殊的函数，主要用来初始化对象，即为对<br>象成员变量赋初始值，它总与new一起使用。我们可以把对象<br>中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</p><a id="more"></a><p>在 JS 中，使用构造函数时要注意以下两点：</p><ul><li>构造函数用于创建某一类对象，其首字母要大写</li><li>构造函数要和 new 一起使用才有意义</li></ul><h3 id="new-在执行时会做四件事情"><a href="#new-在执行时会做四件事情" class="headerlink" title="new 在执行时会做四件事情"></a>new 在执行时会做四件事情</h3><ul><li>在内存中创建一个新的空对象。</li><li>让 this 指向这个新的对象。</li><li>执行构造函数里面的代码，给这个新对象添加属性和方法。</li><li>返回这个新对象（所以构造函数里面不需要 return ）。</li></ul><h3 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h3><p>JavaScript的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的this上添加。通过这两种方式添加的成员，就分别称为==静态成员==和==实例成员==。</p><ul><li>静态成员：在构造函数本身上添加的成员称为静态成员，只能由构造函数本身来访问 。</li><li>实例成员：在构造函数内部创建的对象成员称为实例成员，只能由实例化的对象来访问。<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function Star(name,age)&#123;</span><br><span class="line">    this.name&#x3D;name</span><br><span class="line">    this.age&#x3D;age</span><br><span class="line">    this.sing&#x3D;function()&#123;</span><br><span class="line">        console.log(&#39;SSS&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var XXX&#x3D;new Star(&quot;XX&quot;,&quot;YY&quot;)</span><br><span class="line">&#x2F;&#x2F;1.实例成员就是构造函数内部通过this添加的成员</span><br><span class="line">name age sing 就是实例成员</span><br><span class="line">&#x2F;&#x2F; 实例成员只能通过实例化的对象来访问</span><br><span class="line">console.log(XXX.name);</span><br><span class="line">XXX.sing();</span><br><span class="line">&#x2F;&#x2F; console.log(Star.name);  </span><br><span class="line">&#x2F;&#x2F;不可以通过构造函数来访问实例成员</span><br><span class="line">&#x2F;&#x2F; 2. 静态成员 在构造函数本身上添加的成员  sex 就是静态成员</span><br><span class="line">Star.sex &#x3D; &#39;男&#39;;</span><br><span class="line">&#x2F;&#x2F; 静态成员只能通过构造函数来访问</span><br><span class="line">console.log(Star.sex);</span><br><span class="line">console.log(ldh.sex); &#x2F;&#x2F; 不能通过对象来访问</span><br></pre></td></tr></table></figure></div><h3 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h3>存在浪费内存的问题<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Star(uname, age) &#123;</span><br><span class="line">    this.uname &#x3D; uname;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">    this.sing &#x3D; function() &#123;</span><br><span class="line">        console.log(&#39;我会唱歌&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var ldh &#x3D; new Star(&#39;刘德华&#39;, 18);</span><br><span class="line">var zxy &#x3D; new Star(&#39;张学友&#39;, 19);</span><br></pre></td></tr></table></figure></div><img src="https://github.com/BXsweetheart/youdaoNotes/blob/master/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%AE%E9%A2%98.png?raw=true" alt="image"></li></ul><h3 id="构造函数原型-prototype"><a href="#构造函数原型-prototype" class="headerlink" title="构造函数原型 prototype"></a>构造函数原型 prototype</h3><pre><code>构造函数通过原型分配的函数是所有对象所共享的。</code></pre><ol><li><p>JavaScript 规定，每一个构造函数==都有一个 prototype==<br>属性，指向另一个对象。注意这个prototype就是一个对<br>象，这个对象的所有属性和方法，都会被构造函数所拥有。</p></li><li><p>我们可以把那些不变的方法，直接定义在 prototype<br>对象上，这样所有对象的实例就可以共享这些方法。</p></li><li><p>一般情况下，我们把公共属性定义到构造函数里面，公共的方法我们放到原型对象身上。</p></li></ol><h4 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h4><ol><li>原型是什么 ？<br>一个对象，我们也称为 prototype 为原型对象。</li><li>原型的作用是什么 ？<br>共享方法。</li></ol><h3 id="对象原型-proto"><a href="#对象原型-proto" class="headerlink" title="对象原型  __ proto __"></a>对象原型 __ proto __</h3><p>对象都会有一个属性 __ proto __ 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 __ proto __ 原型的存在。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        function Star(uname, age) &#123;</span><br><span class="line">            this.uname &#x3D; uname;</span><br><span class="line">            this.age &#x3D; age;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Star.prototype.sing &#x3D; function() &#123;</span><br><span class="line">            console.log(&#39;我会唱歌&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        var ldh &#x3D; new Star(&#39;刘德华&#39;, 18);</span><br><span class="line">        var zxy &#x3D; new Star(&#39;张学友&#39;, 19);</span><br><span class="line">        ldh.sing();</span><br><span class="line">        </span><br><span class="line">        console.log(ldh); &#x2F;&#x2F; 对象身上系统自己添加一个 </span><br><span class="line">        __proto__ 指向我们构造函数的原型对象 prototype</span><br><span class="line">        </span><br><span class="line">        console.log(ldh.__proto__ &#x3D;&#x3D;&#x3D; Star.prototype);</span><br><span class="line">        &#x2F;&#x2F; 方法的查找规则: 首先先看ldh 对象身上是否有 </span><br><span class="line">        sing 方法,如果有就执行这个对象上的sing</span><br><span class="line">        &#x2F;&#x2F; 如果没有sing这个方法,因为有__proto__的存在,就</span><br><span class="line">        去构造函数原型对象prototype身上去查找sing这个方法</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></div><p><img src="https://github.com/BXsweetheart/youdaoNotes/blob/master/proto.png?raw=true" alt="image"></p><ul><li><strong>proto</strong>对象原型和原型对象 prototype 是等价的</li><li><strong>proto</strong>对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype</li></ul><h3 id="constructor-构造函数"><a href="#constructor-构造函数" class="headerlink" title="constructor  构造函数"></a>constructor 构造函数</h3><ol><li><p>对象原型（ __ proto __）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性 ，constructor 我们称为构造函数，因为它指回构造函数本身。</p></li><li><p>constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。</p></li><li><p>一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个constructor指向原来的构造函数。</p></li></ol><h3 id="构造函数、实例、原型对象三者之间的关系"><a href="#构造函数、实例、原型对象三者之间的关系" class="headerlink" title="构造函数、实例、原型对象三者之间的关系"></a>构造函数、实例、原型对象三者之间的关系</h3><p><img src="https://github.com/BXsweetheart/youdaoNotes/blob/master/relationship.png?raw=true" alt="image"></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">       function Star(uname, age) &#123;</span><br><span class="line">           this.uname &#x3D; uname;</span><br><span class="line">           this.age &#x3D; age;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 很多情况下,我们需要手动的利用constructor </span><br><span class="line">       这个属性指回原来的构造函数</span><br><span class="line">       &#x2F;&#x2F; Star.prototype.sing &#x3D; function() &#123;</span><br><span class="line">       &#x2F;&#x2F;     console.log(&#39;我会唱歌&#39;);</span><br><span class="line">       &#x2F;&#x2F; &#125;;</span><br><span class="line">       &#x2F;&#x2F; Star.prototype.movie &#x3D; function() &#123;</span><br><span class="line">       &#x2F;&#x2F;     console.log(&#39;我会演电影&#39;);</span><br><span class="line">       &#x2F;&#x2F; &#125;</span><br><span class="line">       Star.prototype &#x3D; &#123;</span><br><span class="line">           &#x2F;&#x2F; 如果我们修改了原来的原型对象,给原型对象赋</span><br><span class="line">           值的是一个对象,则必须手动的利用constructor指</span><br><span class="line">           回原来的构造函数</span><br><span class="line">           constructor: Star,</span><br><span class="line">           sing: function() &#123;</span><br><span class="line">               console.log(&#39;我会唱歌&#39;);</span><br><span class="line">           &#125;,</span><br><span class="line">           movie: function() &#123;</span><br><span class="line">               console.log(&#39;我会演电影&#39;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       var ldh &#x3D; new Star(&#39;刘德华&#39;, 18);</span><br><span class="line">       var zxy &#x3D; new Star(&#39;张学友&#39;, 19);</span><br><span class="line">       console.log(Star.prototype);</span><br><span class="line">       console.log(ldh.__proto__);</span><br><span class="line">       console.log(Star.prototype.constructor);</span><br><span class="line">       console.log(ldh.__proto__.constructor);</span><br><span class="line">   &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></div><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p><img src="https://github.com/BXsweetheart/youdaoNotes/blob/master/%E5%8E%9F%E5%9E%8B%E9%93%BE.png?raw=true" alt="image"></p><ol><li><p>只要是对象就有<strong>proto</strong> 原型, 指向原型对象</p></li><li><p>我们Star原型对象里面的<strong>proto</strong>原型指向的是 Object.prototype</p></li><li><p>我们Object.prototype原型对象里面的<strong>proto</strong>原型 指向为 null</p></li></ol><h3 id="JavaScript-的成员查找机制-规则"><a href="#JavaScript-的成员查找机制-规则" class="headerlink" title="JavaScript 的成员查找机制(规则)"></a>JavaScript 的成员查找机制(规则)</h3><ul><li>当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。</li><li>如果没有就查找它的原型（也就是 <strong>proto</strong>指向的 prototype 原型对象）。</li><li>如果还没有就查找原型对象的原型（Object的原型对象）。</li><li>依此类推一直找到 Object 为止（null）。</li><li><strong>proto</strong>对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。</li></ul><h3 id="原型对象this指向"><a href="#原型对象this指向" class="headerlink" title="原型对象this指向"></a>原型对象this指向</h3><ul><li>构造函数中的this指向我们实例对象。</li><li>原型对象里面放的是方法，这个方法里面的this 指向的是 这个方法的调用者，也就是这个实例对象。</li></ul><h2 id="扩展内置对象"><a href="#扩展内置对象" class="headerlink" title="扩展内置对象"></a>扩展内置对象</h2><p>可以通过原型对象，对原来的内置对象进行扩展自定义的方法。比如给数组增加自定义求偶数和的功能。（原型对象的应用）</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.sum&#x3D;function()&#123;</span><br><span class="line">        var sum&#x3D;0</span><br><span class="line">        for(i&#x3D;0;i&lt;this.length;i++)&#123;</span><br><span class="line">            sum +&#x3D; this[i]</span><br><span class="line">        &#125;</span><br><span class="line">        return sum</span><br><span class="line">    &#125;</span><br><span class="line">    var arr&#x3D;[1,2,3]</span><br><span class="line">    console.log(arr.sum())</span><br></pre></td></tr></table></figure></div><p><strong>注意</strong><br>数组和字符串==内置对象==不能以对象的形式追加，因为会覆盖原本的内置方法——Array.prototype = {} ，只能使用Array.prototype.xxx = function(){} 的方式。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>ES6之前并没有给我们提供extends继承。我们可以通过构造函数+原型对象模拟实现继承，被称为组合继承。</p><h3 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h3><p>调用这个函数, 并且修改函数运行时的 this 指向</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.call(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure></div><ul><li><p>thisArg：当前调用函数 this 的指向对象。</p></li><li><p>arg1，arg2：传递的其他参数。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    function fn(x,y,z)&#123;</span><br><span class="line">        console.log(&quot;deadly sleepy&quot;)</span><br><span class="line">        console.log(this)</span><br><span class="line">        console.log(x+y+z)</span><br><span class="line">    &#125;</span><br><span class="line">    var o&#x3D;&#123;</span><br><span class="line">        think:&quot;want to sleep&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var postgraduate&#x3D;&quot;postgraduate&quot;;</span><br><span class="line">    var is&#x3D;&quot;is&quot;;</span><br><span class="line">    var important&#x3D;&quot;important&quot;</span><br><span class="line">    fn.call()</span><br><span class="line">    fn.call(o)</span><br><span class="line">    fn.call(o,postgraduate,is,important)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></div><h3 id="借用构造函数继承父类型属性"><a href="#借用构造函数继承父类型属性" class="headerlink" title="借用构造函数继承父类型属性"></a>借用构造函数继承父类型属性</h3><p>核心原理：<br>通过 call() 把父类型的 this 指向子类型的 this ，这样就可以实现子类型继承父类型的属性。</p><p>extends属于类的继承，写法是class Son extends Father。<br>这里是函数<br>super()是访问和调用父构造函数的方法<br>call()是继承父构造函数的类和方法</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 父类</span><br><span class="line">function Father(name, age, sex) &#123;</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">  this.age &#x3D; age;</span><br><span class="line">  this.sex &#x3D; sex;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 子类</span><br><span class="line">function Son(name, age, sex, score) &#123;</span><br><span class="line">  Father.call(this, name, age, sex);  &#x2F;&#x2F; 此时父类的 this </span><br><span class="line">  指向子类的 this，同时调用这个函数</span><br><span class="line">  this.score &#x3D; score;</span><br><span class="line">&#125;</span><br><span class="line">var s1 &#x3D; new Son(&#39;zs&#39;, 18, &#39;男&#39;, 100);</span><br><span class="line">console.dir(s1);</span><br></pre></td></tr></table></figure></div><p>子类构造函数中通过call将父类构造函数this指向自身，达到继承父类属性目的</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">       &#x2F;&#x2F; 借用父构造函数继承属性</span><br><span class="line">       &#x2F;&#x2F; 1. 父构造函数</span><br><span class="line">       function Father(uname, age) &#123;</span><br><span class="line">           &#x2F;&#x2F; this 指向父构造函数的对象实例</span><br><span class="line">           this.uname &#x3D; uname;</span><br><span class="line">           this.age &#x3D; age;</span><br><span class="line">       &#125;</span><br><span class="line">       Father.prototype.money &#x3D; function() &#123;</span><br><span class="line">           console.log(100000);</span><br><span class="line"></span><br><span class="line">       &#125;;</span><br><span class="line">       &#x2F;&#x2F; 2 .子构造函数 </span><br><span class="line">       function Son(uname, age, score) &#123;</span><br><span class="line">           &#x2F;&#x2F; this 指向子构造函数的对象实例</span><br><span class="line">           Father.call(this, uname, age);</span><br><span class="line">           this.score &#x3D; score;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; Son.prototype &#x3D; Father.prototype;  </span><br><span class="line">      &#x2F;&#x2F;这样直接赋值会有问题,如果修改了子原型对象,父原型</span><br><span class="line">      &#x2F;&#x2F;对象也会跟着一起变化</span><br><span class="line">       Son.prototype &#x3D; new Father();</span><br><span class="line">       &#x2F;&#x2F; 如果利用对象的形式修改了原型对象,别忘了利用</span><br><span class="line">       &#x2F;&#x2F;constructor 指回原来的构造函数</span><br><span class="line">       Son.prototype.constructor &#x3D; Son;</span><br><span class="line">       &#x2F;&#x2F; 这个是子构造函数专门的方法,原型链查找</span><br><span class="line">       Son.prototype.exam &#x3D; function() &#123;</span><br><span class="line">           console.log(&#39;孩子要考试&#39;);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       var son &#x3D; new Son(&#39;刘德华&#39;, 18, 100);</span><br><span class="line">       console.log(son);</span><br><span class="line">       console.log(Father.prototype);</span><br><span class="line">       console.log(Son.prototype.constructor);</span><br><span class="line">   &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></div><p>一般情况下，对象的方法都在构造函数的原型对象中设置，通过构造函数无法继承父类方法。<br>核心原理：</p></li><li><p>将子类所共享的方法提取出来，让子类的 prototype 原型对象 = new 父类()</p></li><li><p>本质：子类原型对象等于是实例化父类，因为父类实例化之后另外开辟空间，就不会影响原来父类原型对象</p></li><li><p>将子类的 constructor 从新指向子类的构造函数</p></li></ul><h3 id="类的本质"><a href="#类的本质" class="headerlink" title="类的本质"></a>类的本质</h3><ol><li>class本质还是function（简单认为，构造函数的另外一种写法）；</li><li>类的所有方法都定义在类的prototype属性上；</li><li>类创建的实例,里面也有<strong>proto</strong>指向类的prototype原型对象；</li><li>所以ES6的类它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已；</li><li>所以ES6的类其实就是语法糖；</li><li>语法糖:语法糖就是一种便捷写法。简单理解,有两种方法可以实现同样的功能,但是一种写法更加清晰、方便,那么这个方法就是语法糖。</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Feb 23 2020 16:26:56 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;摘要内容&lt;/p&gt;&lt;h2 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#构造函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数&quot;&gt;&lt;/a&gt;构造函数&lt;/h2&gt;&lt;p&gt;构造函数是一种特殊的函数，主要用来初始化对象，即为对&lt;br&gt;象成员变量赋初始值，它总与new一起使用。我们可以把对象&lt;br&gt;中一些公共的属性和方法抽取出来，然后封装到这个函数里面。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="构造函数" scheme="http://yoursite.com/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="http://yoursite.com/posts/54b11a0c.html"/>
    <id>http://yoursite.com/posts/54b11a0c.html</id>
    <published>2020-01-18T12:02:06.000Z</published>
    <updated>2020-02-22T01:16:18.140Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 23 2020 16:26:55 GMT+0800 (GMT+08:00) --><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><blockquote><p>Promise出现的本质是为了解决异步函数回调地狱的问题</p></blockquote><h2 id="1-回调地狱"><a href="#1-回调地狱" class="headerlink" title="1.回调地狱"></a>1.回调地狱</h2><p>曾几何时，我们的代码是这样的，为了拿到回调的结果，不得不<code>callback hell</code>，这种环环相扣的代码可以说是相当恶心了</p><a id="more"></a><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line">fs.readFile(<span class="string">'./a.txt'</span>,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">  fs.readFile(data,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">    fs.readFile(data,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><p>终于，我们的<code>盖世英雄</code>出现了，他身披金甲圣衣、驾着七彩祥云。好吧打岔儿了，没错他就是我们的<code>Promise</code>，那让我们来看看用了<code>Promise</code>之后，上面的代码会变成什么样吧</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    fs.readFile(url,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">error,data</span>)</span>&#123;</span><br><span class="line">      error &amp;&amp; reject(error)</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read(<span class="string">'./a.txt'</span>).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> read(data) </span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> read(data)  </span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><p>如上所示</p><hr><h2 id="2-重点开始，小眼睛都看过来"><a href="#2-重点开始，小眼睛都看过来" class="headerlink" title="2.重点开始，小眼睛都看过来"></a>2.重点开始，小眼睛都看过来</h2><h3 id="2-1constructor"><a href="#2-1constructor" class="headerlink" title="2.1constructor"></a>2.1constructor</h3><p>我们先声明一个类，叫做<code>Promise</code>，里面是构造函数。如果es6还有问题的可以去阮大大的博客上学习一下（传送门☞<a href="http://es6.ruanyifeng.com" target="_blank" rel="noopener">es6</a>）</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor)&#123;</span><br><span class="line">    <span class="comment">//控制状态，使用了一次之后，接下来的都不被使用</span></span><br><span class="line">    <span class="keyword">this</span>.status = <span class="string">'pendding'</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.reason = <span class="literal">undefined</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义resolve函数</span></span><br><span class="line">    <span class="keyword">let</span> resolve = <span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="comment">//这里pendding，主要是为了防止executor中调用了两次resovle或reject方法，而我们只调用一次</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.status===<span class="string">'pendding'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'resolve'</span></span><br><span class="line">        <span class="keyword">this</span>.value = data</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义reject函数</span></span><br><span class="line">    <span class="keyword">let</span> reject = <span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.status===<span class="string">'pendding'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'reject'</span>        </span><br><span class="line">        <span class="keyword">this</span>.reason = data</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//executor方法可能会抛出异常，需要捕获</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="comment">//将resolve和reject函数给使用者      </span></span><br><span class="line">      executor(resolve,reject)      </span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">      <span class="comment">//如果在函数中抛出异常则将它注入reject中</span></span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>那么接下来我会分析一下上面代码的作用，原理：</p></blockquote><ul><li><p><code>executor</code>：这是实例<code>Promise</code>对象时在构造器中传入的参数，一般是一个<code>function(resolve,reject){}</code></p></li><li><p><code>status：Promise</code>的状态，一开始是默认的pendding状态，每当调用道resolve和reject方法时，就会改变其值，在后面的then方法中会用到</p></li><li><p><code>value：resolve</code>回调成功后，调用resolve方法里面的参数值</p></li><li><p><code>reason：reject</code>回调成功后，调用reject方法里面的参数值</p></li><li><p><code>resolve：</code>声明resolve方法在构造器内，通过传入的executor方法传入其中，用以给使用者回调</p></li><li><p><code>reject：</code>声明reject方法在构造器内，通过传入的executor方法传入其中，用以给使用者回调</p></li></ul><h3 id="2-2-then"><a href="#2-2-then" class="headerlink" title="2.2 then"></a>2.2 then</h3><p><code>then</code>方法是<code>Promise</code>中最为重要的方法，他的用法大家都应该已经知道，就是将<code>Promise</code>中的<code>resolve</code>或者<code>reject</code>的结果拿到，那么我们就能知道这里的<code>then</code>方法需要两个参数，成功回调和失败回调，上代码！</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">then(onFufilled,onRejected)&#123;  </span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'resolve'</span>)&#123;</span><br><span class="line">    onFufilled(<span class="keyword">this</span>.value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'reject'</span>)&#123;</span><br><span class="line">    onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这里主要做了将构造器中resolve和reject的结果传入<code>onFufilled</code>和<code>onRejected</code>中，注意这两个是使用者传入的参数，是个方法。所以你以为这么简单就完了？要想更Swag的应对各种场景，我们必须得再完善。继续往下走！</p><h2 id="3-异步的Promise"><a href="#3-异步的Promise" class="headerlink" title="3.异步的Promise"></a>3.异步的Promise</h2><p>之前我们只是处理了同步情况下的Promise，简而言之所有操作都没有异步的成分在内。那么如果是异步该怎么办？</p><h3 id="3-1-callback"><a href="#3-1-callback" class="headerlink" title="3.1 callback"></a>3.1 callback</h3><blockquote><p>最早处理异步的方法就是callback，就相当于我让你帮我扫地，我会在给你发起任务时给你一个手机，之后我做自己的事情去，不用等你，等你扫完地就会打手机给我，诶，我就知道了地扫完了。这个手机就是callback，回调函数。</p></blockquote><p>首先我们需要改一下构造器里的代码，分别添加两个回调函数的数组，分别对应成功回调和失败回调。他们的作用是当成功执行resolve或reject时，执行callback。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存放成功回调的函数</span></span><br><span class="line"><span class="keyword">this</span>.onResolvedCallbacks = []</span><br><span class="line"><span class="comment">//存放失败回调的函数</span></span><br><span class="line"><span class="keyword">this</span>.onRejectedCallbacks = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> resolve = <span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.status===<span class="string">'pendding'</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>.status = <span class="string">'resolve'</span></span><br><span class="line">    <span class="keyword">this</span>.value = data</span><br><span class="line">    <span class="comment">//监听回调函数</span></span><br><span class="line">    <span class="keyword">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span>=&gt;</span>fn())</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> reject = <span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.status===<span class="string">'pendding'</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>.status = <span class="string">'reject'</span>        </span><br><span class="line">    <span class="keyword">this</span>.reason = data</span><br><span class="line">    <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span>=&gt;</span>fn())</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>然后是then需要多加一个状态判断，当Promise中是异步操作时，需要在我们之前定义的回调函数数组中添加一个回调函数。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.status === <span class="string">'pendding'</span>)&#123;</span><br><span class="line">  <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// to do....</span></span><br><span class="line">    <span class="keyword">let</span> x = onFufilled(<span class="keyword">this</span>.value)</span><br><span class="line">    resolvePromise(promise2,x,resolve,reject)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">    resolvePromise(promise2,x,resolve,reject)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>ok！大功告成，异步已经解决了</p><h3 id="3-2-Promise-resolve"><a href="#3-2-Promise-resolve" class="headerlink" title="3.2 Promise.resolve"></a>3.2 Promise.resolve</h3><blockquote><p>一般情况下我们都会使用new Promise（）来创建Promise对象，但是除此之外我们也可以使用其他方法。</p></blockquote><p>静态方法<code>Promise.resolve(value)</code>可以认为是<code>new Promise()</code>方法的快捷方式。</p><p>比如Promise.resolve(20)可以认为是以下代码的语法糖。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">resolve(<span class="number">20</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><h2 id="4-完善Promise"><a href="#4-完善Promise" class="headerlink" title="4.完善Promise"></a>4.完善Promise</h2><blockquote><p>我们现在已经基本完成了<code>Promise</code>的<code>then</code>方法，那么现在我们需要看看他的其他方法。</p></blockquote><h3 id="4-1-catch"><a href="#4-1-catch" class="headerlink" title="4.1 catch"></a>4.1 catch</h3><p>相信大家都知道catch这个方法是用来捕获Promise中的reject的值，也就是相当于then方法中的onRejected回调函数，那么问题就解决了。我们来看代码。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//catch方法</span></span><br><span class="line"><span class="keyword">catch</span>(onRejected)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>,onRejected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>该方法是挂在Promise原型上的方法。当我们调用catch传callback的时候，就相当于是调用了then方法。</p></blockquote><h3 id="4-2-resolve-reject"><a href="#4-2-resolve-reject" class="headerlink" title="4.2 resolve/reject"></a>4.2 resolve/reject</h3><p>大家一定都看到过<code>Promise.resolve()</code>、<code>Promise.reject()</code>这两种用法，它们的作用其实就是返回一个Promise对象，我们来实现一下。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//resolve方法</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(val)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//reject方法</span></span><br><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    reject(val)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>这两个方法是直接可以通过class调用的，原理就是返回一个内部是resolve或reject的Promise对象。</p></blockquote><h3 id="4-3-all"><a href="#4-3-all" class="headerlink" title="4.3 all"></a>4.3 all</h3><p>Promise.all 生成并返回一个新的Promise对象，所以它可以使用Promise实例的所有方法。参数传递promise数组中所有的Promise对象都变为resolve的时候，该方法才会返回，新创建的Promise则会使用这些promise的值。</p><p>如果参数中的任何一个Promise为reject的话，则整个Promise.all调用会立即终止，并返回一个reject的新的Promise对象。</p><p>由于参数数组中的每个元素都是由Promise.resolve包装（wrap）的，所以Promose.all可以处理不同类型的Promose对象。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//all方法(获取所有的promise，都执行then，把结果放到数组，一起返回)</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)<span class="comment">// [1,2,3]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><blockquote><p>其原理就是将参数中的数组取出遍历，每当执行成功都会执行processData方法，processData方法就是用来记录每个Promise的值和它对应的下标，当执行的次数等于数组长度时就会执行resolve，把arr的值给then。这里会有一个坑，如果你是通过arr数组的长度来判断他是否应该resolve的话就会出错，为什么呢？因为js数组的特性，导致如果先出来的是1位置上的值进arr，那么0位置上也会多一个空的值，所以不合理。</p></blockquote><h3 id="4-4-race"><a href="#4-4-race" class="headerlink" title="4.4 race"></a>4.4 race</h3><p>Promise.race 生成并返回一个新的Promise对象。<br>参数Promise数组中的任何一个Promise 对象如果变为resolve 或者reject的话，该函数就会返回，并使用这个Promise 对象的值进行resolve 或者reject。</p><p>注：Promise.race方法只会执行第一个返回的Promise对象</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//race方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(<span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">5000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(<span class="number">2</span>)</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.race([p1(), p2()]).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)<span class="comment">// 三秒钟后打印2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><h2 id="Promise语法糖-deferred"><a href="#Promise语法糖-deferred" class="headerlink" title="Promise语法糖 deferred"></a>Promise语法糖 deferred</h2><p>语法糖这三个字大家一定很熟悉，作为一个很Swag的前端工程师，对<code>async/await</code>这对兄弟肯定很熟悉，没错他们就是<code>generator</code>的语法糖。而我们这里要讲的语法糖是Promise的。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//promise语法糖 也用来测试</span></span><br><span class="line"><span class="built_in">Promise</span>.deferred = <span class="built_in">Promise</span>.defer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dfd = &#123;&#125;</span><br><span class="line">  dfd.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    dfd.resolve = resolve</span><br><span class="line">    dfd.reject = reject</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> dfd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>什么作用呢？看下面代码你就知道了</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="built_in">Promise</span> = <span class="built_in">require</span>(<span class="string">'./promises'</span>)</span><br><span class="line"><span class="comment">//Promise上的语法糖，为了防止嵌套，方便调用</span></span><br><span class="line"><span class="comment">//坏处 错误处理不方便</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> defer = <span class="built_in">Promise</span>.defer()</span><br><span class="line">  fs.readFile(<span class="string">'./1.txt'</span>,<span class="string">'utf8'</span>,(err,data)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)defer.reject(err)</span><br><span class="line">    defer.resolve(data)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> defer.Promise</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>没错，我们可以方便的去调用他语法糖defer中的Promise对象。那么它还有没有另外的方法呢？答案是有的。我们需要在全局上安装promises-aplus-tests插件npm i promises-aplus-tests -g，再输入promises-aplus-tests [js文件名] 即可验证你的Promise的规范。</p></blockquote><p>文章非本人原创，由于原文很多代码比较复杂，本人做了一些简化，看起来容易理解一些，不过没有原文那么详细，知识不问出处，请珍惜他人劳动成果<br>原文地址<a href="https://juejin.im/post/5b32f552f265da59991155f0" target="_blank" rel="noopener">掘金大咖</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Feb 23 2020 16:26:55 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Promise&quot;&gt;&lt;a href=&quot;#Promise&quot; class=&quot;headerlink&quot; title=&quot;Promise&quot;&gt;&lt;/a&gt;Promise&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;Promise出现的本质是为了解决异步函数回调地狱的问题&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;1-回调地狱&quot;&gt;&lt;a href=&quot;#1-回调地狱&quot; class=&quot;headerlink&quot; title=&quot;1.回调地狱&quot;&gt;&lt;/a&gt;1.回调地狱&lt;/h2&gt;&lt;p&gt;曾几何时，我们的代码是这样的，为了拿到回调的结果，不得不&lt;code&gt;callback hell&lt;/code&gt;，这种环环相扣的代码可以说是相当恶心了&lt;/p&gt;
    
    </summary>
    
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
  </entry>
  
  <entry>
    <title>JS运行机制</title>
    <link href="http://yoursite.com/posts/6fdc6fb4.html"/>
    <id>http://yoursite.com/posts/6fdc6fb4.html</id>
    <published>2019-12-20T08:18:14.000Z</published>
    <updated>2020-02-22T02:38:07.624Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 23 2020 16:26:56 GMT+0800 (GMT+08:00) --><h2 id="一、引子"><a href="#一、引子" class="headerlink" title="一、引子"></a>一、引子</h2><p>本文介绍JavaScript运行机制，这一部分比较抽象，我们先从一道面试题入手：</p><a id="more"></a><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 请问数字打印顺序是什么？</span></span><br></pre></td></tr></table></figure></div><p>这一题看似很简单，但如果你不了解JavaScript运行机制，很容易就答错了。题目的答案是依次输出1 2 3，如果你有疑惑，下文有详细解释。</p><h2 id="二、理解JS的单线程的概念"><a href="#二、理解JS的单线程的概念" class="headerlink" title="二、理解JS的单线程的概念"></a>二、理解JS的单线程的概念</h2><p>JavaScript语言的一大特点就是单线程，也就是说，<strong>同一个时间只能做一件事</strong>。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。</p><p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p><h2 id="三、理解任务队列-消息队列"><a href="#三、理解任务队列-消息队列" class="headerlink" title="三、理解任务队列(消息队列)"></a>三、理解任务队列(消息队列)</h2><p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。JavaScript语言的设计者意识到这个问题，将所有任务分成两种，<span style="color:#f40">一种是同步任务（synchronous），另一种是异步任务（asynchronous）</span>。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。<span style="color:#f40">异步任务包括宏任务和微任务(后面会重点介绍)</span>，接下来我们通过两个例子说明同步任务和异步任务的区别：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"A"</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123; &#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"B"</span>);</span><br><span class="line"><span class="comment">// 请问最后的输出结果是什么？</span></span><br></pre></td></tr></table></figure></div><p>如果你的回答是A,恭喜你答对了，因为这是同步任务，程序由上到下执行，遇到while()死循环，下面语句就没办法执行。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"A"</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"B"</span>);</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;&#125;</span><br><span class="line"><span class="comment">// 请问最后的输出结果是什么？</span></span><br></pre></td></tr></table></figure></div><p>如果你的答案是A，恭喜你现在对js运行机制已经有个粗浅的认识了！题目中的setTimeout()就是个异步任务。<strong>在所有同步任务执行完之前，任何的异步任务是不会执行的</strong>，关于这点下文还会详细说明。</p><h2 id="四、理解Event-Loop"><a href="#四、理解Event-Loop" class="headerlink" title="四、理解Event Loop"></a>四、理解Event Loop</h2><p><strong>异步执行的运行机制如下：</strong></p><ol><li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</li><li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li><li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li><li>主线程不断重复上面的第三步。</li></ol><p><strong>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。</strong>这个过程会循环反复。以下这张图可以很好说明这点。<br><img src="/posts/6fdc6fb4/event-loop.png" alt="Event Loop"></p><h2 id="五、哪些语句会放入异步任务队列及放入时机"><a href="#五、哪些语句会放入异步任务队列及放入时机" class="headerlink" title="五、哪些语句会放入异步任务队列及放入时机"></a>五、哪些语句会放入异步任务队列及放入时机</h2><p><strong>一般来说，有以下四种会放入异步任务队列：</strong></p><ol><li>setTimeout和setlnterval</li><li>DOM事件</li><li>ES6中的Promise</li><li>Ajax异步请求</li></ol><p><strong>javascript 代码运行分两个阶段：</strong></p><ol><li>预解析—把所有的函数定义提前，所有的变量声明提前，变量的赋值不提前</li><li>执行—从上到下执行（按照js运行机制）</li></ol><p>至于放入异步任务队列的时机，我们通过 setTimeout的例子和Ajax例子来详细说明：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例题1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line"> <span class="built_in">console</span>.log(i);  </span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 请问最后的输出结果是什么？</span></span><br></pre></td></tr></table></figure></div><p>for循环一次碰到一个 setTimeout()，<span style="color:#f40">并不是马上把setTimeout()拿到异步队列中，而要等到一秒后，才将其放到任务队列里面</span>，一旦”执行栈”中的所有同步任务执行完毕（即for循环结束，此时i已经为5），系统就会读取已经存放”任务队列”的setTimeout()（有五个），于是答案是输出5个5。</p><p>上面也提到，<span style="color:#EFEFDA"><strong>在到达指定时间时，定时器就会将相应回调函数插入“任务队列”尾部。这就是“定时器（timer）”功能。</strong></span></p><ul><li>关于定时器的重要补充：<br>定时器包括setTimeout与 setInterval 两个方法。它们的第二个参数是指定其回调函数推迟/每隔多少毫秒数后执行。</li></ul><p>对于第二个参数有以下需要注意的地方：</p><p>当第二个参数缺省时，默认为 0；</p><p>当指定的值小于 4 毫秒，则增加到 4ms(4ms 是 HTML5 标准指定的，对于 2010 年及之前的浏览器则是 10ms);也就是说至少需要4毫秒，该setTimeout()拿到任务队列中。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例题2</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">url：“xxxxx<span class="string">",</span></span><br><span class="line"><span class="string">success:function (result)&#123;</span></span><br><span class="line"><span class="string">console.log("</span>a<span class="string">")</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">setTimeout(function ()&#123;</span></span><br><span class="line"><span class="string">console.log("</span>b<span class="string">")</span></span><br><span class="line"><span class="string">&#125;,100)</span></span><br><span class="line"><span class="string">setTimeout(function ()&#123;</span></span><br><span class="line"><span class="string">console.log("</span>c<span class="string">")</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">console.log("</span>d<span class="string">");</span></span><br></pre></td></tr></table></figure></div><p><img src="/posts/6fdc6fb4/ajax.png" alt></p><p>ajax加载完成时才会放入异步队列，至于这段时间不确定，所有有两种情况：①大于100ms,最后的结果是 d c b a ;②小于100ms,最后的结果便是d c a b。</p><h2 id="六、微任务-Microtask-与宏任务-Macrotask"><a href="#六、微任务-Microtask-与宏任务-Macrotask" class="headerlink" title="六、微任务(Microtask)与宏任务(Macrotask)"></a>六、微任务(Microtask)与宏任务(Macrotask)</h2><p>我们上面提到异步任务分为宏任务和微任务，宏任务队列可以有多个，微任务队列只有一个。</p><ul><li>宏任务包括：script(全局任务), setTimeout, setInterval, setImmediate, I/O, UI rendering。</li><li>微任务包括: new Promise().then(回调), process.nextTick, Object.observe(已废弃), MutationObserver(html5新特性)</li></ul><p><strong>当执行栈中的所有同步任务执行完毕时，是先执行宏任务还是微任务呢？</strong></p><ul><li>由于执行代码入口都是全局任务 script，而全局任务属于宏任务，所以当栈为空，同步任务任务执行完毕时，会先执行微任务队列里的任务。</li><li>微任务队列里的任务全部执行完毕后，会读取宏任务队列中拍最前的任务。</li><li>执行宏任务的过程中，遇到微任务，依次加入微任务队列。</li><li>栈空后，再次读取微任务队列里的任务，依次类推。</li></ul><p><img src="/posts/6fdc6fb4/no-referrer.png" alt="no-referrer"></p><p>一句话概括上面的流程图：<span style="color:#f40">当某个宏任务队列的中的任务全部执行完以后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，就查看是否有其他宏任务队列。</span></p><p>接下来我们看两道例子来介绍上面流程：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>)  </span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>)</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise2'</span>)    </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br></pre></td></tr></table></figure></div><p>最后输出结果是Promise1，setTimeout1，Promise2，setTimeout2</p><ul><li>一开始执行栈的同步任务执行完毕，会去查看是否有微任务队列，上题中存在(有且只有一个)，然后执行微任务队列中的所有任务输出Promise1，同时会生成一个宏任务 setTimeout2</li><li>然后去查看宏任务队列，宏任务 setTimeout1 在 setTimeout2 之前，先执行宏任务 setTimeout1，输出 setTimeout1</li><li>在执行宏任务setTimeout1时会生成微任务Promise2 ，放入微任务队列中，接着先去清空微任务队列中的所有任务，输出 Promise2</li><li>清空完微任务队列中的所有任务后，就又会去宏任务队列取一个，这回执行的是 setTimeout2</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'----------------- start -----------------'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">  resolve();  <span class="comment">// 修改promise实例对象的状态为成功的状态</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise实例成功回调执行'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'----------------- end -----------------'</span>);</span><br></pre></td></tr></table></figure></div><p><img src="/posts/6fdc6fb4/start-end.png" alt></p><h2 id="七、解析"><a href="#七、解析" class="headerlink" title="七、解析"></a>七、解析</h2><p>如果要输出0~4，上面例题应该如何修改？</p><ol><li><p>将var变为let</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li><p>加个立即执行函数</p></li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="3"><li>也可以通过这样加闭包</li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i &lt; <span class="number">5</span>;i++)&#123;  </span><br><span class="line">  <span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">      <span class="keyword">var</span> j = i;    </span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">          <span class="built_in">console</span>.log(j);  </span><br><span class="line">      &#125;,<span class="number">1000</span>)  </span><br><span class="line">  &#125;    </span><br><span class="line">a();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Feb 23 2020 16:26:56 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;一、引子&quot;&gt;&lt;a href=&quot;#一、引子&quot; class=&quot;headerlink&quot; title=&quot;一、引子&quot;&gt;&lt;/a&gt;一、引子&lt;/h2&gt;&lt;p&gt;本文介绍JavaScript运行机制，这一部分比较抽象，我们先从一道面试题入手：&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>原型和原型链</title>
    <link href="http://yoursite.com/posts/139b1e40.html"/>
    <id>http://yoursite.com/posts/139b1e40.html</id>
    <published>2019-12-18T10:02:46.000Z</published>
    <updated>2020-02-21T13:43:00.431Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 23 2020 16:26:56 GMT+0800 (GMT+08:00) --><h2 id="原型对象prototype"><a href="#原型对象prototype" class="headerlink" title="原型对象prototype"></a>原型对象prototype</h2><ul><li>每一个函数对象都有一个prototype属性，但是普通对象是没有的</li><li>普通对象都是通过函数创建的<a id="more"></a><blockquote><p>在 ECMAScript 核心所定义的全部属性中，最耐人寻味的就要数 prototype 属性了。对于 ECMAScript 中的引用类型而言，prototype 是保存着它们所有实例方法的真正所在。换句话所说，诸如 toString()和 valuseOf()等方法实际上都保存在 prototype 名下，只不过是通过各自对象的实例访问罢了。—-《JavaScript 高级程序设计》</p></blockquote></li></ul><p>JS所有对象分为函数对象和普通对象。凡是通过new Function()创建得来的对象都是函数对象。函数对象拥有prototype属性和proto属性。</p><p><strong>prototype</strong></p><blockquote><p>JS设计之初为了实现简单继承，引入了prototype属性，也叫原型对象（显式原型）。</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Animal.prototype) <span class="comment">//Object  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype) <span class="comment">// Object</span></span><br></pre></td></tr></table></figure></div><p>可以看出，从本质上讲，prototype是一个普通对象，是函数对象的构造函数创建的一个实例。相当于在Animal创建的时候，自动创建了一个它的实例，并且把这个实例赋值给了prototype。</p><p>但是存在一个特例Function， Function.prototype是原型对象，本质却是函数对象。作为一个函数对象，又没有prototype属性</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype) <span class="comment">// 特殊 Function  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype.prototype) <span class="comment">//undefined 函数对象却没有prototype属性</span></span><br></pre></td></tr></table></figure></div><p><strong>proto属性</strong><br>所有的对象obj(null和undefined除外)都具有proto属性（隐式原型），proto属性在本质上为一个指针，指向创造obj对象的函数对象的prototype属性。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age= age;</span><br><span class="line">        &#125;</span><br><span class="line">        Animal.prototype = &#123;</span><br><span class="line">            alertName()&#123;</span><br><span class="line">                alert(<span class="keyword">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建实例</span></span><br><span class="line">        <span class="keyword">var</span> dog = <span class="keyword">new</span> Animal(<span class="string">"大黄"</span>);</span><br><span class="line">        dog .print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             alert(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">        dog.print();  <span class="comment">//大黄</span></span><br><span class="line">        dog.alertName();  <span class="comment">//大黄</span></span><br></pre></td></tr></table></figure></div><p>print()方法是dog实例本身具有的方法，所以dog.print()输出“大黄”；alertName()不属于dog实例的方法，属于构造函数的方法，dog.alertName()也会输出“大黄”，是因为dog实例继承了构造函数的方法。</p><p>实例dog的隐式原型指向它构造函数的显式原型，指向的意思是恒等于，即</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dog.__proto__ === Animal.prototype<span class="comment">// true</span></span><br></pre></td></tr></table></figure></div><h2 id="构造器constructor"><a href="#构造器constructor" class="headerlink" title="构造器constructor"></a>构造器constructor</h2><p>构造器constructor就是用来构造函数对象的，constructor 属性返回对创建此对象的函数对象的引用。通俗了讲就是指向当前对象的爸爸</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a.constructor===<span class="built_in">Function</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(a.prototype.constructor===a); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></div><p>函数a是由Function创造出来,那么它的constructor指向的Function,a.prototype是由new a()方式创造出来,那么a.prototype.constructor理应指向a。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>原型链是JS中实现继承的主要方法。其基本思想就是让一个引用类型继承另一个引用类型的属性和方法。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.animalType = <span class="string">"animal"</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">Animal.prototype.getAnimalType = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.animalType ;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.Dogtype = <span class="string">"dog"</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal();  </span><br><span class="line"></span><br><span class="line">Dog.prototype.getDogType = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.Dogtype ;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dahuang = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line">alert(dahuang.getAnimalType ());<span class="comment">// animal</span></span><br></pre></td></tr></table></figure></div><p>dahuang.getAnimalType ()打印结果为animal，dahuang自身没有getAnimalType ()方法，那么就会去它的proto(即它的构造函数的prototype)中寻找，发现Dog中也没有，于是顺着proto再往上找，在<code>Animal.prototype.getAnimalType</code>找到，返回结果 。</p><p><code>如果Animal中还是没有，就接着往上找，一直到Object.prototype原型对象终止</code></p><ul><li>总结得出<strong>原型链</strong>就是：<br>如果在对象上没有找到需要的属性或者方法引用，引擎就会在[[prototype]]关联的对象上进行查找。同理，如果在后者中也没有找到需要的引用就会继续查找它[[prototype]，以此类推。一直到<code>Object.prototype</code>原型对象终止，这就是原型链。<code>Object.prototype</code>是原型链的顶端。</li></ul><p><code>如果找到Object.prototype上还找不到，原路返回，告诉实例此方法或属性没有找到或者没有定义。如果说在中间的任意一个环节找到了，就停止向上查找直接返回结果</code></p><h2 id="原型对象和原型链的作用"><a href="#原型对象和原型链的作用" class="headerlink" title="原型对象和原型链的作用"></a>原型对象和原型链的作用</h2><p>如果构造函数中有很多属性和方法，那么构造函数所有的实例化对象都是公用这些属性和方法的，当有多个实例想用共用这些东西的时候，每个实例都拷贝一份，就造成极大的资源浪费，那是不是可以考虑存把这些需要共用的属性和方法放到一个共同的东西上。这个共同的东西就是原型对象（prototype）。</p><p><code>当然原型链实现继承也会存在一些问题，最主要的问题来自包含引用类型的原型。其次就是在创建子类型的实例时，不能向超类型的构造函数中传递参数。</code></p><h2 id="构造函数、实例对象、原型对象三者之间的关系"><a href="#构造函数、实例对象、原型对象三者之间的关系" class="headerlink" title="构造函数、实例对象、原型对象三者之间的关系"></a>构造函数、实例对象、原型对象三者之间的关系</h2><p><img src="/posts/139b1e40/yuanxing.webp" alt="构造函数、实例对象、原型三者的关系"></p><p>任何函数都具有一个 prototype 属性，该属性是一个对象。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(F.prototype) <span class="comment">// =&gt; object</span></span><br><span class="line"></span><br><span class="line">F.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hi!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>构造函数的 <code>prototype</code> 对象默认都有一个 <code>constructor</code> 属性，指向 <code>prototype</code> 对象所在函数。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(F.constructor === F) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure></div><p>通过构造函数得到的实例对象内部会包含一个指向构造函数的 <code>prototype</code> 对象的指针 <code>__proto__</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> F()</span><br><span class="line"><span class="built_in">console</span>.log(instance.__proto__ === F.prototype) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure></div><p><code>__proto__</code> 是非标准属性。</p><p>实例对象可以直接访问原型对象成员。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance.sayHi() <span class="comment">// =&gt; hi!</span></span><br></pre></td></tr></table></figure></div><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul><li>任何函数都具有一个 <code>prototype</code> 属性，该属性是一个对象</li><li>构造函数的 <code>prototype</code> 对象默认都有一个 <code>constructor</code> 属性，指向 <code>prototype</code> 对象所在函数</li><li>通过构造函数得到的实例对象内部会包含一个指向构造函数的 <code>prototype</code> 对象的指针 <code>__proto__</code></li><li>所有实例都直接或间接继承了原型对象的成员</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Feb 23 2020 16:26:56 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;原型对象prototype&quot;&gt;&lt;a href=&quot;#原型对象prototype&quot; class=&quot;headerlink&quot; title=&quot;原型对象prototype&quot;&gt;&lt;/a&gt;原型对象prototype&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;每一个函数对象都有一个prototype属性，但是普通对象是没有的&lt;/li&gt;&lt;li&gt;普通对象都是通过函数创建的&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript/apply、call和bind方法</title>
    <link href="http://yoursite.com/posts/384c131e.html"/>
    <id>http://yoursite.com/posts/384c131e.html</id>
    <published>2019-11-18T14:32:45.000Z</published>
    <updated>2020-02-18T12:35:34.266Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 23 2020 16:26:56 GMT+0800 (GMT+08:00) --><h2 id="三者的相似之处"><a href="#三者的相似之处" class="headerlink" title="三者的相似之处"></a>三者的相似之处</h2><ol><li>都是用来改变函数的this对象的指向的。</li><li>第一个参数都是this要指向的对象。</li><li>都可以利用后续参数传参。<a id="more"></a><h2 id="apply方法"><a href="#apply方法" class="headerlink" title="apply方法"></a>apply方法</h2>apply的使用语法：</li></ol><blockquote><p>函数名字.apply(对象,[参数1,参数2,…]);<br>方法名字.apply(对象,[参数1,参数2,…]);<br>apply方法是以数组的方式传递参数</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取按钮</span></span><br><span class="line"><span class="keyword">var</span> btn=<span class="built_in">document</span>.querySelectorAll(<span class="string">".btn"</span>);</span><br><span class="line"><span class="comment">// 使用apply方法,改变Array中forEach方法的指向,循环遍历解析按钮注册点击事件</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.forEach.apply(btn,[<span class="function"><span class="keyword">function</span> (<span class="params">ele</span>) </span>&#123;</span><br><span class="line">addEventListener(ele,<span class="string">"click"</span>,clickHandle);</span><br><span class="line">&#125;]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是window对象的方法:"</span>+(x+y)+<span class="keyword">this</span>.sex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.fn(<span class="number">50</span>,<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个对象</span></span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">age:<span class="number">10</span>,</span><br><span class="line">sex:<span class="string">"男"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.fn.apply(obj,[<span class="number">10</span>,<span class="number">20</span>]);<span class="comment">//30男</span></span><br></pre></td></tr></table></figure></div><p>无论是系统构造函数的方法，还是自己定义的函数方法，都可以通过apply方法来改变this的指向</p><h2 id="call方法"><a href="#call方法" class="headerlink" title="call方法"></a>call方法</h2><p>call的使用语法：</p><blockquote><p>函数名字.call(对象,参数1,参数2,…);<br>方法名字.call(对象,参数1,参数2,…);<br>call方法是以字符串形式传递参数</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有的点赞标签</span></span><br><span class="line"><span class="keyword">var</span> praise=<span class="built_in">document</span>.querySelectorAll(<span class="string">".praise"</span>);</span><br><span class="line"><span class="comment">// 使用call方法,改变Array中forEach方法的指向,遍历点赞标签，注册点击事件</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(praise,(<span class="function"><span class="keyword">function</span> (<span class="params">ele</span>) </span>&#123;</span><br><span class="line">addEventListener(ele,<span class="string">"click"</span>,praHandle);</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是window对象的方法:"</span>+(x+y)+<span class="keyword">this</span>.sex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.fn(<span class="number">50</span>,<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个对象</span></span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">age:<span class="number">10</span>,</span><br><span class="line">sex:<span class="string">"男"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.fn.call(obj,<span class="number">10</span>,<span class="number">50</span>);<span class="comment">//60男</span></span><br></pre></td></tr></table></figure></div><p>无论是系统构造函数的方法，还是自己定义的函数方法，都可以通过call方法来改变this的指向</p><h2 id="bind方法"><a href="#bind方法" class="headerlink" title="bind方法"></a>bind方法</h2><blockquote><p>bind方法是复制的意思,参数可以在复制的时候传进去,也可以在复制之后调用的时候传入进去<br>apply和call是调用的时候改变this指向<br>bind方法,是赋值一份的时候,改变了this的指向</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 人的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加原型方法</span></span><br><span class="line">Person.prototype.play=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>+<span class="string">"====&gt;"</span>+<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 学生的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化对象</span></span><br><span class="line"><span class="keyword">var</span> per=<span class="keyword">new</span> Person(<span class="number">60</span>);</span><br><span class="line"><span class="keyword">var</span> stu=<span class="keyword">new</span> Student(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过bind方法赋值一份</span></span><br><span class="line"><span class="keyword">var</span> ff=per.play.bind(stu);</span><br><span class="line">ff();</span><br></pre></td></tr></table></figure></div><ul><li>bind是用来复制一份</li></ul><p>使用的语法:</p><blockquote><p>函数名字.bind(对象,参数1,参数2,…);—-&gt;返回值是复制之后的这个函数<br>方法名字.bind(对象,参数1,参数2,…);—-&gt;返回值是复制之后的这个方法</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Feb 23 2020 16:26:56 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;三者的相似之处&quot;&gt;&lt;a href=&quot;#三者的相似之处&quot; class=&quot;headerlink&quot; title=&quot;三者的相似之处&quot;&gt;&lt;/a&gt;三者的相似之处&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;都是用来改变函数的this对象的指向的。&lt;/li&gt;&lt;li&gt;第一个参数都是this要指向的对象。&lt;/li&gt;&lt;li&gt;都可以利用后续参数传参。&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
  </entry>
  
</feed>
