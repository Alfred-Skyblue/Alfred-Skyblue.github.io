<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端小站</title>
  
  <subtitle>每一个不曾起舞的日子，都是对生命的辜负</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-16T09:00:13.908Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>丶远方</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>apply、call和bind方法</title>
    <link href="http://yoursite.com/2020/02/16/apply%E3%80%81call%E5%92%8Cbind%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/02/16/apply%E3%80%81call%E5%92%8Cbind%E6%96%B9%E6%B3%95/</id>
    <published>2020-02-16T08:58:10.094Z</published>
    <updated>2020-02-16T09:00:13.908Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]</p><h2 id="apply方法"><a href="#apply方法" class="headerlink" title="apply方法"></a>apply方法</h2><p>apply方法用于改变this的指向</p><p>apply的使用语法：</p><blockquote><p>函数名字.apply(对象,[参数1,参数2,…]);<br>方法名字.apply(对象,[参数1,参数2,…]);<br>apply方法是以数组的方式传递参数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取按钮</span></span><br><span class="line"><span class="keyword">var</span> btn=<span class="built_in">document</span>.querySelectorAll(<span class="string">".btn"</span>);</span><br><span class="line"><span class="comment">// 使用apply方法,改变Array中forEach方法的指向,循环遍历解析按钮注册点击事件</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.forEach.apply(btn,[<span class="function"><span class="keyword">function</span> (<span class="params">ele</span>) </span>&#123;</span><br><span class="line">addEventListener(ele,<span class="string">"click"</span>,clickHandle);</span><br><span class="line">&#125;]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是window对象的方法:"</span>+(x+y)+<span class="keyword">this</span>.sex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.fn(<span class="number">50</span>,<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个对象</span></span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">age:<span class="number">10</span>,</span><br><span class="line">sex:<span class="string">"男"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.fn.apply(obj,[<span class="number">10</span>,<span class="number">20</span>]);<span class="comment">//30男</span></span><br></pre></td></tr></table></figure><p>无论是系统构造函数的方法，还是自己定义的函数方法，都可以通过apply方法来改变this的指向</p><h2 id="call方法"><a href="#call方法" class="headerlink" title="call方法"></a>call方法</h2><p>call的使用语法：</p><blockquote><p>函数名字.call(对象,参数1,参数2,…);<br>方法名字.call(对象,参数1,参数2,…);<br>call方法是以字符串形式传递参数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有的点赞标签</span></span><br><span class="line"><span class="keyword">var</span> praise=<span class="built_in">document</span>.querySelectorAll(<span class="string">".praise"</span>);</span><br><span class="line"><span class="comment">// 使用call方法,改变Array中forEach方法的指向,遍历点赞标签，注册点击事件</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(praise,(<span class="function"><span class="keyword">function</span> (<span class="params">ele</span>) </span>&#123;</span><br><span class="line">addEventListener(ele,<span class="string">"click"</span>,praHandle);</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是window对象的方法:"</span>+(x+y)+<span class="keyword">this</span>.sex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.fn(<span class="number">50</span>,<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个对象</span></span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">age:<span class="number">10</span>,</span><br><span class="line">sex:<span class="string">"男"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.fn.call(obj,<span class="number">10</span>,<span class="number">50</span>);<span class="comment">//60男</span></span><br></pre></td></tr></table></figure><p>无论是系统构造函数的方法，还是自己定义的函数方法，都可以通过call方法来改变this的指向</p><h2 id="bind方法"><a href="#bind方法" class="headerlink" title="bind方法"></a>bind方法</h2><blockquote><p>bind方法是复制的意思,参数可以在复制的时候传进去,也可以在复制之后调用的时候传入进去<br>apply和call是调用的时候改变this指向<br>bind方法,是赋值一份的时候,改变了this的指向</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 人的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加原型方法</span></span><br><span class="line">Person.prototype.play=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>+<span class="string">"====&gt;"</span>+<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 学生的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化对象</span></span><br><span class="line"><span class="keyword">var</span> per=<span class="keyword">new</span> Person(<span class="number">60</span>);</span><br><span class="line"><span class="keyword">var</span> stu=<span class="keyword">new</span> Student(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过bind方法赋值一份</span></span><br><span class="line"><span class="keyword">var</span> ff=per.play.bind(stu);</span><br><span class="line">ff();</span><br></pre></td></tr></table></figure><ul><li>bind是用来复制一份</li></ul><p>使用的语法:</p><blockquote><p>函数名字.bind(对象,参数1,参数2,…);—-&gt;返回值是复制之后的这个函数<br>方法名字.bind(对象,参数1,参数2,…);—-&gt;返回值是复制之后的这个方法</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@[toc]&lt;/p&gt;
&lt;h2 id=&quot;apply方法&quot;&gt;&lt;a href=&quot;#apply方法&quot; class=&quot;headerlink&quot; title=&quot;apply方法&quot;&gt;&lt;/a&gt;apply方法&lt;/h2&gt;&lt;p&gt;apply方法用于改变this的指向&lt;/p&gt;
&lt;p&gt;apply的使用语法
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue生命周期详解</title>
    <link href="http://yoursite.com/2020/02/16/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/02/16/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-02-16T08:24:50.000Z</published>
    <updated>2020-02-16T08:50:53.141Z</updated>
    
    <content type="html"><![CDATA[<p>Vue实例有一个完整的生命周期，也就是说从开始创建、初始化数据、编译模板、挂在DOM、渲染-更新-渲染、卸载等一系列过程，我们成为Vue 实例的生命周期，钩子就是在某个阶段给你一个做某些处理的机会。</p><p><img src="vue1.jpg" alt="生命周期图"></p><center><font color=#ccc>生命周期图</font> </center><hr><p><img src="vue2.jpg" alt=""></p><ul><li><p>beforeCreate(创建前)<br>在实例初始化之后，数据观测和事件配置之前被调用，此时组件的选项对象还未创建，el 和 data 并未初始化，因此无法访问methods， data， computed等上的方法和数据。</p></li><li><p>created(创建后)<br>实例已经创建完成之后被调用，在这一步，实例已完成以下配置：数据观测、属性和方法的运算，watch/event事件回调，完成了data 数据的初始化，el没有。 然而，挂在阶段还没有开始, $el属性目前不可见，这是一个常用的生命周期，因为你可以调用methods中的方法，改变data中的数据，并且修改可以通过vue的响应式绑定体现在页面上，，获取computed中的计算属性等等，通常我们可以在这里对实例进行预处理，也有一些童鞋喜欢在这里发ajax请求，值得注意的是，这个周期中是没有什么方法来对实例化过程进行拦截的，因此假如有某些数据必须获取才允许进入页面的话，并不适合在这个方法发请求，建议在组件路由钩子beforeRouteEnter中完成</p></li><li><p>beforeMount<br>挂在开始之前被调用，相关的render函数首次被调用（虚拟DOM），实例已完成以下的配置： 编译模板，把data里面的数据和模板生成html，完成了el和data 初始化，注意此时还没有挂在html到页面上。</p></li><li><p>mounted<br>挂在完成，也就是模板中的HTML渲染到HTML页面中，此时一般可以做一些ajax操作，mounted只会执行一次。</p></li><li><p>beforeUpdate<br>在数据更新之前被调用，发生在虚拟DOM重新渲染和打补丁之前，可以在该钩子中进一步地更改状态，不会触发附加地重渲染过程</p></li><li><p>updated(更新后)<br>在由于数据更改导致地虚拟DOM重新渲染和打补丁只会调用，调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作，然后在大多是情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环，该钩子在服务器端渲染期间不被调用</p></li><li><p>beforeDestrioy(销毁前)<br>在实例销毁之前调用，实例仍然完全可用，</p></li></ul><ol><li>这一步还可以用this来获取实例</li><li>一般在这一步做一些重置的操作，比如清除掉组件中的定时器 和 监听的dom事件</li></ol><ul><li>destroyed(销毁后)<br>在实例销毁之后调用，调用后，所以的事件监听器会被移出，所有的子实例也会被销毁，该钩子在服务器端渲染期间不被调用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vue实例有一个完整的生命周期，也就是说从开始创建、初始化数据、编译模板、挂在DOM、渲染-更新-渲染、卸载等一系列过程，我们成为Vue 实例的生命周期，钩子就是在某个阶段给你一个做某些处理的机会。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;vue1.jpg&quot; alt=&quot;生命周期图
      
    
    </summary>
    
    
      <category term="-Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>构造函数（第二节）</title>
    <link href="http://yoursite.com/2020/02/15/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E7%AC%AC%E4%BA%8C%E8%8A%82%EF%BC%89/"/>
    <id>http://yoursite.com/2020/02/15/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E7%AC%AC%E4%BA%8C%E8%8A%82%EF%BC%89/</id>
    <published>2020-02-15T12:52:15.316Z</published>
    <updated>2020-02-16T09:00:12.218Z</updated>
    
    <content type="html"><![CDATA[<p>摘要内容</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><pre><code>构造函数是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与new一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</code></pre><a id="more"></a><p>在 JS 中，使用构造函数时要注意以下两点：</p><ul><li>构造函数用于创建某一类对象，其首字母要大写</li><li>构造函数要和 new 一起使用才有意义</li></ul><h3 id="new-在执行时会做四件事情"><a href="#new-在执行时会做四件事情" class="headerlink" title="new 在执行时会做四件事情"></a>new 在执行时会做四件事情</h3><ul><li>在内存中创建一个新的空对象。</li><li>让 this 指向这个新的对象。</li><li>执行构造函数里面的代码，给这个新对象添加属性和方法。</li><li>返回这个新对象（所以构造函数里面不需要 return ）。</li></ul><h3 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h3><p>JavaScript的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的this上添加。通过这两种方式添加的成员，就分别称为==静态成员==和==实例成员==。</p><ul><li>静态成员：在构造函数本身上添加的成员称为静态成员，只能由构造函数本身来访问 。</li><li>实例成员：在构造函数内部创建的对象成员称为实例成员，只能由实例化的对象来访问。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function Star(name,age)&#123;</span><br><span class="line">    this.name&#x3D;name</span><br><span class="line">    this.age&#x3D;age</span><br><span class="line">    this.sing&#x3D;function()&#123;</span><br><span class="line">        console.log(&#39;SSS&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var XXX&#x3D;new Star(&quot;XX&quot;,&quot;YY&quot;)</span><br><span class="line">&#x2F;&#x2F;1.实例成员就是构造函数内部通过this添加的成员</span><br><span class="line">name age sing 就是实例成员</span><br><span class="line">&#x2F;&#x2F; 实例成员只能通过实例化的对象来访问</span><br><span class="line">console.log(XXX.name);</span><br><span class="line">XXX.sing();</span><br><span class="line">&#x2F;&#x2F; console.log(Star.name);  </span><br><span class="line">&#x2F;&#x2F;不可以通过构造函数来访问实例成员</span><br><span class="line">&#x2F;&#x2F; 2. 静态成员 在构造函数本身上添加的成员  sex 就是静态成员</span><br><span class="line">Star.sex &#x3D; &#39;男&#39;;</span><br><span class="line">&#x2F;&#x2F; 静态成员只能通过构造函数来访问</span><br><span class="line">console.log(Star.sex);</span><br><span class="line">console.log(ldh.sex); &#x2F;&#x2F; 不能通过对象来访问</span><br></pre></td></tr></table></figure><h3 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h3>存在浪费内存的问题<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Star(uname, age) &#123;</span><br><span class="line">    this.uname &#x3D; uname;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">    this.sing &#x3D; function() &#123;</span><br><span class="line">        console.log(&#39;我会唱歌&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var ldh &#x3D; new Star(&#39;刘德华&#39;, 18);</span><br><span class="line">var zxy &#x3D; new Star(&#39;张学友&#39;, 19);</span><br></pre></td></tr></table></figure><img src="https://github.com/BXsweetheart/youdaoNotes/blob/master/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%AE%E9%A2%98.png?raw=true" alt="image"></li></ul><h3 id="构造函数原型-prototype"><a href="#构造函数原型-prototype" class="headerlink" title="构造函数原型 prototype"></a>构造函数原型 prototype</h3><pre><code>构造函数通过原型分配的函数是所有对象所共享的。</code></pre><ol><li><p>JavaScript 规定，每一个构造函数==都有一个 prototype==<br>属性，指向另一个对象。注意这个prototype就是一个对<br>象，这个对象的所有属性和方法，都会被构造函数所拥有。</p></li><li><p>我们可以把那些不变的方法，直接定义在 prototype<br>对象上，这样所有对象的实例就可以共享这些方法。</p></li><li><p>一般情况下，我们把公共属性定义到构造函数里面，公共的方法我们放到原型对象身上。</p></li></ol><h4 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h4><ol><li>原型是什么 ？<br>一个对象，我们也称为 prototype 为原型对象。</li><li>原型的作用是什么 ？<br>共享方法。</li></ol><h3 id="对象原型-proto"><a href="#对象原型-proto" class="headerlink" title="对象原型  __ proto __"></a>对象原型  __ proto __</h3><p>对象都会有一个属性 __ proto __ 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 __ proto __ 原型的存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        function Star(uname, age) &#123;</span><br><span class="line">            this.uname &#x3D; uname;</span><br><span class="line">            this.age &#x3D; age;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Star.prototype.sing &#x3D; function() &#123;</span><br><span class="line">            console.log(&#39;我会唱歌&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        var ldh &#x3D; new Star(&#39;刘德华&#39;, 18);</span><br><span class="line">        var zxy &#x3D; new Star(&#39;张学友&#39;, 19);</span><br><span class="line">        ldh.sing();</span><br><span class="line">        </span><br><span class="line">        console.log(ldh); &#x2F;&#x2F; 对象身上系统自己添加一个 </span><br><span class="line">        __proto__ 指向我们构造函数的原型对象 prototype</span><br><span class="line">        </span><br><span class="line">        console.log(ldh.__proto__ &#x3D;&#x3D;&#x3D; Star.prototype);</span><br><span class="line">        &#x2F;&#x2F; 方法的查找规则: 首先先看ldh 对象身上是否有 </span><br><span class="line">        sing 方法,如果有就执行这个对象上的sing</span><br><span class="line">        &#x2F;&#x2F; 如果没有sing这个方法,因为有__proto__的存在,就</span><br><span class="line">        去构造函数原型对象prototype身上去查找sing这个方法</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/BXsweetheart/youdaoNotes/blob/master/proto.png?raw=true" alt="image"></p><ul><li><strong>proto</strong>对象原型和原型对象 prototype 是等价的</li><li><strong>proto</strong>对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype</li></ul><h3 id="constructor-构造函数"><a href="#constructor-构造函数" class="headerlink" title="constructor  构造函数"></a>constructor  构造函数</h3><ol><li><p>对象原型（ __ proto __）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性 ，constructor 我们称为构造函数，因为它指回构造函数本身。</p></li><li><p>constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。</p></li><li><p>一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个constructor指向原来的构造函数。</p></li></ol><h3 id="构造函数、实例、原型对象三者之间的关系"><a href="#构造函数、实例、原型对象三者之间的关系" class="headerlink" title="构造函数、实例、原型对象三者之间的关系"></a>构造函数、实例、原型对象三者之间的关系</h3><p><img src="https://github.com/BXsweetheart/youdaoNotes/blob/master/relationship.png?raw=true" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">       function Star(uname, age) &#123;</span><br><span class="line">           this.uname &#x3D; uname;</span><br><span class="line">           this.age &#x3D; age;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 很多情况下,我们需要手动的利用constructor </span><br><span class="line">       这个属性指回原来的构造函数</span><br><span class="line">       &#x2F;&#x2F; Star.prototype.sing &#x3D; function() &#123;</span><br><span class="line">       &#x2F;&#x2F;     console.log(&#39;我会唱歌&#39;);</span><br><span class="line">       &#x2F;&#x2F; &#125;;</span><br><span class="line">       &#x2F;&#x2F; Star.prototype.movie &#x3D; function() &#123;</span><br><span class="line">       &#x2F;&#x2F;     console.log(&#39;我会演电影&#39;);</span><br><span class="line">       &#x2F;&#x2F; &#125;</span><br><span class="line">       Star.prototype &#x3D; &#123;</span><br><span class="line">           &#x2F;&#x2F; 如果我们修改了原来的原型对象,给原型对象赋</span><br><span class="line">           值的是一个对象,则必须手动的利用constructor指</span><br><span class="line">           回原来的构造函数</span><br><span class="line">           constructor: Star,</span><br><span class="line">           sing: function() &#123;</span><br><span class="line">               console.log(&#39;我会唱歌&#39;);</span><br><span class="line">           &#125;,</span><br><span class="line">           movie: function() &#123;</span><br><span class="line">               console.log(&#39;我会演电影&#39;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       var ldh &#x3D; new Star(&#39;刘德华&#39;, 18);</span><br><span class="line">       var zxy &#x3D; new Star(&#39;张学友&#39;, 19);</span><br><span class="line">       console.log(Star.prototype);</span><br><span class="line">       console.log(ldh.__proto__);</span><br><span class="line">       console.log(Star.prototype.constructor);</span><br><span class="line">       console.log(ldh.__proto__.constructor);</span><br><span class="line">   &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p><img src="https://github.com/BXsweetheart/youdaoNotes/blob/master/%E5%8E%9F%E5%9E%8B%E9%93%BE.png?raw=true" alt="image"></p><ol><li><p>只要是对象就有<strong>proto</strong> 原型, 指向原型对象</p></li><li><p>我们Star原型对象里面的<strong>proto</strong>原型指向的是 Object.prototype</p></li><li><p>我们Object.prototype原型对象里面的<strong>proto</strong>原型  指向为 null</p></li></ol><h3 id="JavaScript-的成员查找机制-规则"><a href="#JavaScript-的成员查找机制-规则" class="headerlink" title="JavaScript 的成员查找机制(规则)"></a>JavaScript 的成员查找机制(规则)</h3><ul><li>当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。</li><li>如果没有就查找它的原型（也就是 <strong>proto</strong>指向的 prototype 原型对象）。</li><li>如果还没有就查找原型对象的原型（Object的原型对象）。</li><li>依此类推一直找到 Object 为止（null）。</li><li><strong>proto</strong>对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。</li></ul><h3 id="原型对象this指向"><a href="#原型对象this指向" class="headerlink" title="原型对象this指向"></a>原型对象this指向</h3><ul><li>构造函数中的this指向我们实例对象。</li><li>原型对象里面放的是方法，这个方法里面的this 指向的是 这个方法的调用者，也就是这个实例对象。</li></ul><h2 id="扩展内置对象"><a href="#扩展内置对象" class="headerlink" title="扩展内置对象"></a>扩展内置对象</h2><p>可以通过原型对象，对原来的内置对象进行扩展自定义的方法。比如给数组增加自定义求偶数和的功能。（原型对象的应用）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.sum&#x3D;function()&#123;</span><br><span class="line">        var sum&#x3D;0</span><br><span class="line">        for(i&#x3D;0;i&lt;this.length;i++)&#123;</span><br><span class="line">            sum +&#x3D; this[i]</span><br><span class="line">        &#125;</span><br><span class="line">        return sum</span><br><span class="line">    &#125;</span><br><span class="line">    var arr&#x3D;[1,2,3]</span><br><span class="line">    console.log(arr.sum())</span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>数组和字符串==内置对象==不能以对象的形式追加，因为会覆盖原本的内置方法——Array.prototype = {} ，只能使用Array.prototype.xxx = function(){} 的方式。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>ES6之前并没有给我们提供extends继承。我们可以通过构造函数+原型对象模拟实现继承，被称为组合继承。</p><h3 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h3><p>调用这个函数, 并且修改函数运行时的 this 指向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.call(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure><ul><li><p>thisArg：当前调用函数 this 的指向对象。</p></li><li><p>arg1，arg2：传递的其他参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    function fn(x,y,z)&#123;</span><br><span class="line">        console.log(&quot;deadly sleepy&quot;)</span><br><span class="line">        console.log(this)</span><br><span class="line">        console.log(x+y+z)</span><br><span class="line">    &#125;</span><br><span class="line">    var o&#x3D;&#123;</span><br><span class="line">        think:&quot;want to sleep&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var postgraduate&#x3D;&quot;postgraduate&quot;;</span><br><span class="line">    var is&#x3D;&quot;is&quot;;</span><br><span class="line">    var important&#x3D;&quot;important&quot;</span><br><span class="line">    fn.call()</span><br><span class="line">    fn.call(o)</span><br><span class="line">    fn.call(o,postgraduate,is,important)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="借用构造函数继承父类型属性"><a href="#借用构造函数继承父类型属性" class="headerlink" title="借用构造函数继承父类型属性"></a>借用构造函数继承父类型属性</h3><p>核心原理：<br>通过 call() 把父类型的 this 指向子类型的 this ，这样就可以实现子类型继承父类型的属性。</p><p>  extends属于类的继承，写法是class Son extends Father。<br>  这里是函数<br>  super()是访问和调用父构造函数的方法<br>  call()是继承父构造函数的类和方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 父类</span><br><span class="line">function Father(name, age, sex) &#123;</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">  this.age &#x3D; age;</span><br><span class="line">  this.sex &#x3D; sex;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 子类</span><br><span class="line">function Son(name, age, sex, score) &#123;</span><br><span class="line">  Father.call(this, name, age, sex);  &#x2F;&#x2F; 此时父类的 this </span><br><span class="line">  指向子类的 this，同时调用这个函数</span><br><span class="line">  this.score &#x3D; score;</span><br><span class="line">&#125;</span><br><span class="line">var s1 &#x3D; new Son(&#39;zs&#39;, 18, &#39;男&#39;, 100);</span><br><span class="line">console.dir(s1);</span><br></pre></td></tr></table></figure><p>子类构造函数中通过call将父类构造函数this指向自身，达到继承父类属性目的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">       &#x2F;&#x2F; 借用父构造函数继承属性</span><br><span class="line">       &#x2F;&#x2F; 1. 父构造函数</span><br><span class="line">       function Father(uname, age) &#123;</span><br><span class="line">           &#x2F;&#x2F; this 指向父构造函数的对象实例</span><br><span class="line">           this.uname &#x3D; uname;</span><br><span class="line">           this.age &#x3D; age;</span><br><span class="line">       &#125;</span><br><span class="line">       Father.prototype.money &#x3D; function() &#123;</span><br><span class="line">           console.log(100000);</span><br><span class="line"></span><br><span class="line">       &#125;;</span><br><span class="line">       &#x2F;&#x2F; 2 .子构造函数 </span><br><span class="line">       function Son(uname, age, score) &#123;</span><br><span class="line">           &#x2F;&#x2F; this 指向子构造函数的对象实例</span><br><span class="line">           Father.call(this, uname, age);</span><br><span class="line">           this.score &#x3D; score;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; Son.prototype &#x3D; Father.prototype;  </span><br><span class="line">      &#x2F;&#x2F;这样直接赋值会有问题,如果修改了子原型对象,父原型</span><br><span class="line">      &#x2F;&#x2F;对象也会跟着一起变化</span><br><span class="line">       Son.prototype &#x3D; new Father();</span><br><span class="line">       &#x2F;&#x2F; 如果利用对象的形式修改了原型对象,别忘了利用</span><br><span class="line">       &#x2F;&#x2F;constructor 指回原来的构造函数</span><br><span class="line">       Son.prototype.constructor &#x3D; Son;</span><br><span class="line">       &#x2F;&#x2F; 这个是子构造函数专门的方法,原型链查找</span><br><span class="line">       Son.prototype.exam &#x3D; function() &#123;</span><br><span class="line">           console.log(&#39;孩子要考试&#39;);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       var son &#x3D; new Son(&#39;刘德华&#39;, 18, 100);</span><br><span class="line">       console.log(son);</span><br><span class="line">       console.log(Father.prototype);</span><br><span class="line">       console.log(Son.prototype.constructor);</span><br><span class="line">   &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>一般情况下，对象的方法都在构造函数的原型对象中设置，通过构造函数无法继承父类方法。<br>核心原理： </p></li><li><p>将子类所共享的方法提取出来，让子类的 prototype 原型对象 = new 父类()  </p></li><li><p>本质：子类原型对象等于是实例化父类，因为父类实例化之后另外开辟空间，就不会影响原来父类原型对象</p></li><li><p>将子类的 constructor 从新指向子类的构造函数</p></li></ul><h3 id="类的本质"><a href="#类的本质" class="headerlink" title="类的本质"></a>类的本质</h3><ol><li>class本质还是function（简单认为，构造函数的另外一种写法）；</li><li>类的所有方法都定义在类的prototype属性上；</li><li>类创建的实例,里面也有<strong>proto</strong>指向类的prototype原型对象；</li><li>所以ES6的类它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已；</li><li>所以ES6的类其实就是语法糖；</li><li>语法糖:语法糖就是一种便捷写法。简单理解,有两种方法可以实现同样的功能,但是一种写法更加清晰、方便,那么这个方法就是语法糖。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要内容&lt;/p&gt;
&lt;h2 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#构造函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数&quot;&gt;&lt;/a&gt;构造函数&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;构造函数是一种特殊的函数，主要用来初始化对象，即为对
象成员变量赋初始值，它总与new一起使用。我们可以把对象
中一些公共的属性和方法抽取出来，然后封装到这个函数里面。&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="构造函数" scheme="http://yoursite.com/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>hexo</title>
    <link href="http://yoursite.com/2020/01/08/hexo/"/>
    <id>http://yoursite.com/2020/01/08/hexo/</id>
    <published>2020-01-08T00:30:14.775Z</published>
    <updated>2020-02-16T08:05:45.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建本地博客"><a href="#创建本地博客" class="headerlink" title="创建本地博客"></a>创建本地博客</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1.基于node</span><br><span class="line">2.npm包管理工具</span><br><span class="line">3.npm install -g hexo(hexo-cli)</span><br><span class="line">4.下载的资源是国外的可能比较慢</span><br><span class="line">5.淘宝镜像（代理的仓库）</span><br><span class="line">6.npm install -g hexo --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">7.在一个空目录（hexo init）博客系统的初始化</span><br><span class="line">8.hexo\source\_posts md文档就是博客文档</span><br><span class="line">9.如果要写一篇博客（新建文件  xxx.md）</span><br><span class="line">10.把md文档转html文件（hexo g）</span><br><span class="line">11.在自己的服务器预览（hexo s） localhost:4000</span><br><span class="line">12.如果从新生成html文件可能会有缓存 （hexo clean,hexo g）</span><br><span class="line"></span><br><span class="line">13.和github关联 推代码到github</span><br><span class="line">14.和git关联 hexo-deploy-git 插件（安装 npm install hexo-deployer-git --save ）</span><br><span class="line">15.和github关联需要配置文件</span><br><span class="line">16.修改文件  _config.yml  在最下面</span><br><span class="line">17.</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:Alfred-Skyblue&#x2F;Akfred.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line">18. 需要在github配置仓库 名称（用户名.github.io）</span><br><span class="line">19. 把代码推到github (hexo d)</span><br><span class="line">20. 只能预览代码 无法预览页面</span><br><span class="line">21. 配置当前仓库可以通过网络访问页面</span><br><span class="line">22. 在仓库的首页  settings---&gt;GitHub Pages--&gt;改选项 Source（none---master branch）</span><br><span class="line">23. 通过 用户名.github.io 访问你的博客</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;创建本地博客&quot;&gt;&lt;a href=&quot;#创建本地博客&quot; class=&quot;headerlink&quot; title=&quot;创建本地博客&quot;&gt;&lt;/a&gt;创建本地博客&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/01/08/hello-world/"/>
    <id>http://yoursite.com/2020/01/08/hello-world/</id>
    <published>2020-01-07T23:56:03.174Z</published>
    <updated>2020-01-07T23:56:03.174Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
